
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000173c  00006b00  00006b00  00006b00  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .gnu.sgstubs  00000000  00000000  00000000  00010008  2**0
                  CONTENTS
  2 .relocate     00000008  20000000  0000823c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00002ca4  20000008  00008244  00010008  2**2
                  ALLOC
  4 .heap         00000204  20002cac  0000aee8  00010008  2**0
                  ALLOC
  5 .stack        00000400  20002eb0  0000b0ec  00010008  2**0
                  ALLOC
  6 .ARM.attributes 0000002c  00000000  00000000  00010008  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  00010034  2**0
                  CONTENTS, READONLY
  8 .debug_info   0000bb25  00000000  00000000  0001008d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001de8  00000000  00000000  0001bbb2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000610  00000000  00000000  0001d99a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000960  00000000  00000000  0001dfaa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00017827  00000000  00000000  0001e90a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00005f30  00000000  00000000  00036131  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0008a98b  00000000  00000000  0003c061  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000fe8  00000000  00000000  000c69ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00005171  00000000  00000000  000c79d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00006b00 <exception_table>:
    6b00:	b0 32 00 20 75 6c 00 00 71 6c 00 00 71 6c 00 00     .2. ul..ql..ql..
	...
    6b2c:	71 6c 00 00 00 00 00 00 00 00 00 00 d1 7f 00 00     ql..............
    6b3c:	15 80 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ....ql..ql..ql..
    6b4c:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6b5c:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6b6c:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6b7c:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6b8c:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6b9c:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6bac:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6bbc:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6bcc:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6bdc:	71 6c 00 00 71 6c 00 00 71 6c 00 00 71 6c 00 00     ql..ql..ql..ql..
    6bec:	71 6c 00 00 71 6c 00 00                             ql..ql..

00006bf4 <__do_global_dtors_aux>:
    6bf4:	b510      	push	{r4, lr}
    6bf6:	f240 0408 	movw	r4, #8
    6bfa:	f2c2 0400 	movt	r4, #8192	; 0x2000
    6bfe:	7823      	ldrb	r3, [r4, #0]
    6c00:	b963      	cbnz	r3, 6c1c <__do_global_dtors_aux+0x28>
    6c02:	f240 0300 	movw	r3, #0
    6c06:	f2c0 0300 	movt	r3, #0
    6c0a:	b12b      	cbz	r3, 6c18 <__do_global_dtors_aux+0x24>
    6c0c:	f248 203c 	movw	r0, #33340	; 0x823c
    6c10:	f2c0 0000 	movt	r0, #0
    6c14:	e000      	b.n	6c18 <__do_global_dtors_aux+0x24>
    6c16:	bf00      	nop
    6c18:	2301      	movs	r3, #1
    6c1a:	7023      	strb	r3, [r4, #0]
    6c1c:	bd10      	pop	{r4, pc}
    6c1e:	46c0      	nop			; (mov r8, r8)

00006c20 <frame_dummy>:
    6c20:	f240 0300 	movw	r3, #0
    6c24:	f2c0 0300 	movt	r3, #0
    6c28:	b510      	push	{r4, lr}
    6c2a:	b14b      	cbz	r3, 6c40 <frame_dummy+0x20>
    6c2c:	f240 010c 	movw	r1, #12
    6c30:	f248 203c 	movw	r0, #33340	; 0x823c
    6c34:	f2c2 0100 	movt	r1, #8192	; 0x2000
    6c38:	f2c0 0000 	movt	r0, #0
    6c3c:	e000      	b.n	6c40 <frame_dummy+0x20>
    6c3e:	bf00      	nop
    6c40:	f248 203c 	movw	r0, #33340	; 0x823c
    6c44:	f2c0 0000 	movt	r0, #0
    6c48:	6803      	ldr	r3, [r0, #0]
    6c4a:	b903      	cbnz	r3, 6c4e <frame_dummy+0x2e>
    6c4c:	bd10      	pop	{r4, pc}
    6c4e:	f240 0300 	movw	r3, #0
    6c52:	f2c0 0300 	movt	r3, #0
    6c56:	2b00      	cmp	r3, #0
    6c58:	d0f8      	beq.n	6c4c <frame_dummy+0x2c>
    6c5a:	4798      	blx	r3
    6c5c:	e7f6      	b.n	6c4c <frame_dummy+0x2c>
    6c5e:	46c0      	nop			; (mov r8, r8)

00006c60 <SystemCoreClockUpdate>:
 *         retrieved from cpu registers.
 */
void SystemCoreClockUpdate(void)
{
	// Not implemented
	SystemCoreClock = __SYSTEM_CLOCK;
    6c60:	4a01      	ldr	r2, [pc, #4]	; (6c68 <SystemCoreClockUpdate+0x8>)
    6c62:	4b02      	ldr	r3, [pc, #8]	; (6c6c <SystemCoreClockUpdate+0xc>)
    6c64:	601a      	str	r2, [r3, #0]
	return;
}
    6c66:	4770      	bx	lr
    6c68:	003d0900 	.word	0x003d0900
    6c6c:	20000000 	.word	0x20000000

00006c70 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    6c70:	e7fe      	b.n	6c70 <Dummy_Handler>
	...

00006c74 <Reset_Handler>:
	if (pSrc != pDest) {
    6c74:	4a10      	ldr	r2, [pc, #64]	; (6cb8 <Reset_Handler+0x44>)
    6c76:	4b11      	ldr	r3, [pc, #68]	; (6cbc <Reset_Handler+0x48>)
{
    6c78:	b510      	push	{r4, lr}
	if (pSrc != pDest) {
    6c7a:	429a      	cmp	r2, r3
    6c7c:	d005      	beq.n	6c8a <Reset_Handler+0x16>
    6c7e:	2300      	movs	r3, #0
		for (; pDest < &_erelocate;) {
    6c80:	490f      	ldr	r1, [pc, #60]	; (6cc0 <Reset_Handler+0x4c>)
    6c82:	4a0e      	ldr	r2, [pc, #56]	; (6cbc <Reset_Handler+0x48>)
    6c84:	189a      	adds	r2, r3, r2
    6c86:	428a      	cmp	r2, r1
    6c88:	d30e      	bcc.n	6ca8 <Reset_Handler+0x34>
		*pDest++ = 0;
    6c8a:	2100      	movs	r1, #0
    6c8c:	4b0d      	ldr	r3, [pc, #52]	; (6cc4 <Reset_Handler+0x50>)
	for (pDest = &_szero; pDest < &_ezero;) {
    6c8e:	4a0e      	ldr	r2, [pc, #56]	; (6cc8 <Reset_Handler+0x54>)
    6c90:	4293      	cmp	r3, r2
    6c92:	d30f      	bcc.n	6cb4 <Reset_Handler+0x40>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    6c94:	217f      	movs	r1, #127	; 0x7f
    6c96:	4b0d      	ldr	r3, [pc, #52]	; (6ccc <Reset_Handler+0x58>)
    6c98:	4a0d      	ldr	r2, [pc, #52]	; (6cd0 <Reset_Handler+0x5c>)
    6c9a:	438b      	bics	r3, r1
    6c9c:	6093      	str	r3, [r2, #8]
	__libc_init_array();
    6c9e:	4b0d      	ldr	r3, [pc, #52]	; (6cd4 <Reset_Handler+0x60>)
    6ca0:	4798      	blx	r3
	main();
    6ca2:	4b0d      	ldr	r3, [pc, #52]	; (6cd8 <Reset_Handler+0x64>)
    6ca4:	4798      	blx	r3
    6ca6:	e7fe      	b.n	6ca6 <Reset_Handler+0x32>
			*pDest++ = *pSrc++;
    6ca8:	4803      	ldr	r0, [pc, #12]	; (6cb8 <Reset_Handler+0x44>)
    6caa:	1818      	adds	r0, r3, r0
    6cac:	6800      	ldr	r0, [r0, #0]
    6cae:	3304      	adds	r3, #4
    6cb0:	6010      	str	r0, [r2, #0]
    6cb2:	e7e6      	b.n	6c82 <Reset_Handler+0xe>
		*pDest++ = 0;
    6cb4:	c302      	stmia	r3!, {r1}
    6cb6:	e7eb      	b.n	6c90 <Reset_Handler+0x1c>
    6cb8:	0000823c 	.word	0x0000823c
    6cbc:	20000000 	.word	0x20000000
    6cc0:	20000008 	.word	0x20000008
    6cc4:	20000008 	.word	0x20000008
    6cc8:	20002cac 	.word	0x20002cac
    6ccc:	00006b00 	.word	0x00006b00
    6cd0:	e000ed00 	.word	0xe000ed00
    6cd4:	00008191 	.word	0x00008191
    6cd8:	0000808d 	.word	0x0000808d

00006cdc <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
    6cdc:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
    6cde:	4b02      	ldr	r3, [pc, #8]	; (6ce8 <delay_init+0xc>)
    6ce0:	6018      	str	r0, [r3, #0]
    6ce2:	4b02      	ldr	r3, [pc, #8]	; (6cec <delay_init+0x10>)
    6ce4:	4798      	blx	r3
}
    6ce6:	bd10      	pop	{r4, pc}
    6ce8:	20000024 	.word	0x20000024
    6cec:	00006cf1 	.word	0x00006cf1

00006cf0 <_delay_init>:
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
	(void)hw;
}
    6cf0:	4770      	bx	lr
	...

00006cf4 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6cf4:	4b05      	ldr	r3, [pc, #20]	; (6d0c <prvResetNextTaskUnblockTime+0x18>)
    6cf6:	681a      	ldr	r2, [r3, #0]
    6cf8:	6812      	ldr	r2, [r2, #0]
    6cfa:	b912      	cbnz	r2, 6d02 <prvResetNextTaskUnblockTime+0xe>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    6cfc:	3a01      	subs	r2, #1
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    6cfe:	605a      	str	r2, [r3, #4]
	}
}
    6d00:	4770      	bx	lr
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6d02:	681a      	ldr	r2, [r3, #0]
    6d04:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    6d06:	68d2      	ldr	r2, [r2, #12]
    6d08:	6852      	ldr	r2, [r2, #4]
    6d0a:	e7f8      	b.n	6cfe <prvResetNextTaskUnblockTime+0xa>
    6d0c:	20000028 	.word	0x20000028

00006d10 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    6d10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6d12:	0005      	movs	r5, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    6d14:	4e12      	ldr	r6, [pc, #72]	; (6d60 <prvAddCurrentTaskToDelayedList+0x50>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6d16:	4b13      	ldr	r3, [pc, #76]	; (6d64 <prvAddCurrentTaskToDelayedList+0x54>)
const TickType_t xConstTickCount = xTickCount;
    6d18:	68b7      	ldr	r7, [r6, #8]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6d1a:	68f0      	ldr	r0, [r6, #12]
{
    6d1c:	9101      	str	r1, [sp, #4]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6d1e:	3004      	adds	r0, #4
    6d20:	4798      	blx	r3
    6d22:	0034      	movs	r4, r6
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    6d24:	1c6b      	adds	r3, r5, #1
    6d26:	d108      	bne.n	6d3a <prvAddCurrentTaskToDelayedList+0x2a>
    6d28:	9b01      	ldr	r3, [sp, #4]
    6d2a:	b133      	cbz	r3, 6d3a <prvAddCurrentTaskToDelayedList+0x2a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6d2c:	0030      	movs	r0, r6
    6d2e:	68f1      	ldr	r1, [r6, #12]
    6d30:	4b0d      	ldr	r3, [pc, #52]	; (6d68 <prvAddCurrentTaskToDelayedList+0x58>)
    6d32:	3104      	adds	r1, #4
    6d34:	3010      	adds	r0, #16

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6d36:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    6d38:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6d3a:	68e3      	ldr	r3, [r4, #12]
			xTimeToWake = xConstTickCount + xTicksToWait;
    6d3c:	197d      	adds	r5, r7, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6d3e:	605d      	str	r5, [r3, #4]
    6d40:	4b0a      	ldr	r3, [pc, #40]	; (6d6c <prvAddCurrentTaskToDelayedList+0x5c>)
			if( xTimeToWake < xConstTickCount )
    6d42:	42af      	cmp	r7, r5
    6d44:	d903      	bls.n	6d4e <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6d46:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6d48:	68e1      	ldr	r1, [r4, #12]
    6d4a:	3104      	adds	r1, #4
    6d4c:	e7f3      	b.n	6d36 <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6d4e:	6820      	ldr	r0, [r4, #0]
    6d50:	68e1      	ldr	r1, [r4, #12]
    6d52:	3104      	adds	r1, #4
    6d54:	4798      	blx	r3
				if( xTimeToWake < xNextTaskUnblockTime )
    6d56:	6863      	ldr	r3, [r4, #4]
    6d58:	429d      	cmp	r5, r3
    6d5a:	d2ed      	bcs.n	6d38 <prvAddCurrentTaskToDelayedList+0x28>
					xNextTaskUnblockTime = xTimeToWake;
    6d5c:	6065      	str	r5, [r4, #4]
}
    6d5e:	e7eb      	b.n	6d38 <prvAddCurrentTaskToDelayedList+0x28>
    6d60:	20000028 	.word	0x20000028
    6d64:	00007adb 	.word	0x00007adb
    6d68:	00007a95 	.word	0x00007a95
    6d6c:	00007aad 	.word	0x00007aad

00006d70 <prvIdleTask>:
{
    6d70:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    6d72:	4c0f      	ldr	r4, [pc, #60]	; (6db0 <prvIdleTask+0x40>)
    6d74:	6c23      	ldr	r3, [r4, #64]	; 0x40
    6d76:	b92b      	cbnz	r3, 6d84 <prvIdleTask+0x14>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    6d78:	6c63      	ldr	r3, [r4, #68]	; 0x44
    6d7a:	2b01      	cmp	r3, #1
    6d7c:	d9f9      	bls.n	6d72 <prvIdleTask+0x2>
				taskYIELD();
    6d7e:	4b0d      	ldr	r3, [pc, #52]	; (6db4 <prvIdleTask+0x44>)
    6d80:	4798      	blx	r3
    6d82:	e7f6      	b.n	6d72 <prvIdleTask+0x2>
			taskENTER_CRITICAL();
    6d84:	4b0c      	ldr	r3, [pc, #48]	; (6db8 <prvIdleTask+0x48>)
    6d86:	4798      	blx	r3
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6d88:	6b63      	ldr	r3, [r4, #52]	; 0x34
    6d8a:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6d8c:	4b0b      	ldr	r3, [pc, #44]	; (6dbc <prvIdleTask+0x4c>)
    6d8e:	1d28      	adds	r0, r5, #4
    6d90:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    6d92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    6d94:	3b01      	subs	r3, #1
    6d96:	63e3      	str	r3, [r4, #60]	; 0x3c
				--uxDeletedTasksWaitingCleanUp;
    6d98:	6c23      	ldr	r3, [r4, #64]	; 0x40
    6d9a:	3b01      	subs	r3, #1
    6d9c:	6423      	str	r3, [r4, #64]	; 0x40
			taskEXIT_CRITICAL();
    6d9e:	4b08      	ldr	r3, [pc, #32]	; (6dc0 <prvIdleTask+0x50>)
    6da0:	4798      	blx	r3
			vPortFree( pxTCB->pxStack );
    6da2:	4c08      	ldr	r4, [pc, #32]	; (6dc4 <prvIdleTask+0x54>)
    6da4:	6b28      	ldr	r0, [r5, #48]	; 0x30
    6da6:	47a0      	blx	r4
			vPortFree( pxTCB );
    6da8:	0028      	movs	r0, r5
    6daa:	47a0      	blx	r4
    6dac:	e7e1      	b.n	6d72 <prvIdleTask+0x2>
    6dae:	46c0      	nop			; (mov r8, r8)
    6db0:	20000028 	.word	0x20000028
    6db4:	00007f75 	.word	0x00007f75
    6db8:	00007f8d 	.word	0x00007f8d
    6dbc:	00007adb 	.word	0x00007adb
    6dc0:	00007fa5 	.word	0x00007fa5
    6dc4:	00007e81 	.word	0x00007e81

00006dc8 <xTaskCreate>:
	{
    6dc8:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    6dca:	0097      	lsls	r7, r2, #2
	{
    6dcc:	b085      	sub	sp, #20
    6dce:	9001      	str	r0, [sp, #4]
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    6dd0:	4c53      	ldr	r4, [pc, #332]	; (6f20 <xTaskCreate+0x158>)
    6dd2:	0038      	movs	r0, r7
	{
    6dd4:	000e      	movs	r6, r1
    6dd6:	9302      	str	r3, [sp, #8]
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    6dd8:	47a0      	blx	r4
    6dda:	0005      	movs	r5, r0
			if( pxStack != NULL )
    6ddc:	b150      	cbz	r0, 6df4 <xTaskCreate+0x2c>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    6dde:	2054      	movs	r0, #84	; 0x54
    6de0:	47a0      	blx	r4
    6de2:	0004      	movs	r4, r0
				if( pxNewTCB != NULL )
    6de4:	b118      	cbz	r0, 6dee <xTaskCreate+0x26>
					pxNewTCB->pxStack = pxStack;
    6de6:	6305      	str	r5, [r0, #48]	; 0x30
	configASSERT( pcName );
    6de8:	b93e      	cbnz	r6, 6dfa <xTaskCreate+0x32>
    6dea:	b672      	cpsid	i
    6dec:	e7fe      	b.n	6dec <xTaskCreate+0x24>
					vPortFree( pxStack );
    6dee:	0028      	movs	r0, r5
    6df0:	4b4c      	ldr	r3, [pc, #304]	; (6f24 <xTaskCreate+0x15c>)
    6df2:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    6df4:	2601      	movs	r6, #1
    6df6:	4276      	negs	r6, r6
    6df8:	e085      	b.n	6f06 <xTaskCreate+0x13e>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    6dfa:	003a      	movs	r2, r7
    6dfc:	4b4a      	ldr	r3, [pc, #296]	; (6f28 <xTaskCreate+0x160>)
    6dfe:	21a5      	movs	r1, #165	; 0xa5
    6e00:	0028      	movs	r0, r5
    6e02:	4798      	blx	r3
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    6e04:	6b23      	ldr	r3, [r4, #48]	; 0x30
    6e06:	1f3a      	subs	r2, r7, #4
    6e08:	189a      	adds	r2, r3, r2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    6e0a:	2307      	movs	r3, #7
    6e0c:	439a      	bics	r2, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    6e0e:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    6e10:	9200      	str	r2, [sp, #0]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    6e12:	001a      	movs	r2, r3
    6e14:	5cf1      	ldrb	r1, [r6, r3]
    6e16:	3234      	adds	r2, #52	; 0x34
    6e18:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == ( char ) 0x00 )
    6e1a:	5cf2      	ldrb	r2, [r6, r3]
    6e1c:	b112      	cbz	r2, 6e24 <xTaskCreate+0x5c>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    6e1e:	3301      	adds	r3, #1
    6e20:	2b05      	cmp	r3, #5
    6e22:	d1f6      	bne.n	6e12 <xTaskCreate+0x4a>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    6e24:	0023      	movs	r3, r4
    6e26:	2700      	movs	r7, #0
    6e28:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    6e2a:	3338      	adds	r3, #56	; 0x38
    6e2c:	701f      	strb	r7, [r3, #0]
    6e2e:	2d04      	cmp	r5, #4
    6e30:	d900      	bls.n	6e34 <xTaskCreate+0x6c>
    6e32:	2504      	movs	r5, #4
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    6e34:	1d23      	adds	r3, r4, #4
    6e36:	0018      	movs	r0, r3
	pxNewTCB->uxPriority = uxPriority;
    6e38:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    6e3a:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    6e3c:	4e3b      	ldr	r6, [pc, #236]	; (6f2c <xTaskCreate+0x164>)
		pxNewTCB->uxMutexesHeld = 0;
    6e3e:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    6e40:	9303      	str	r3, [sp, #12]
    6e42:	47b0      	blx	r6
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    6e44:	0020      	movs	r0, r4
    6e46:	3018      	adds	r0, #24
    6e48:	47b0      	blx	r6
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6e4a:	2305      	movs	r3, #5
    6e4c:	1b5d      	subs	r5, r3, r5
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6e4e:	0023      	movs	r3, r4
    6e50:	3350      	adds	r3, #80	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    6e52:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6e54:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    6e56:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    6e58:	64e7      	str	r7, [r4, #76]	; 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    6e5a:	9a02      	ldr	r2, [sp, #8]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6e5c:	701f      	strb	r7, [r3, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    6e5e:	9901      	ldr	r1, [sp, #4]
    6e60:	4b33      	ldr	r3, [pc, #204]	; (6f30 <xTaskCreate+0x168>)
    6e62:	9800      	ldr	r0, [sp, #0]
    6e64:	4798      	blx	r3
	if( pxCreatedTask != NULL )
    6e66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    6e68:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
    6e6a:	b103      	cbz	r3, 6e6e <xTaskCreate+0xa6>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    6e6c:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
    6e6e:	4d31      	ldr	r5, [pc, #196]	; (6f34 <xTaskCreate+0x16c>)
	taskENTER_CRITICAL();
    6e70:	4b31      	ldr	r3, [pc, #196]	; (6f38 <xTaskCreate+0x170>)
    6e72:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    6e74:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    6e76:	4f31      	ldr	r7, [pc, #196]	; (6f3c <xTaskCreate+0x174>)
    6e78:	3301      	adds	r3, #1
    6e7a:	63eb      	str	r3, [r5, #60]	; 0x3c
		if( pxCurrentTCB == NULL )
    6e7c:	68eb      	ldr	r3, [r5, #12]
    6e7e:	2b00      	cmp	r3, #0
    6e80:	d144      	bne.n	6f0c <xTaskCreate+0x144>
			pxCurrentTCB = pxNewTCB;
    6e82:	60ec      	str	r4, [r5, #12]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    6e84:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    6e86:	2b01      	cmp	r3, #1
    6e88:	d120      	bne.n	6ecc <xTaskCreate+0x104>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6e8a:	0028      	movs	r0, r5
    6e8c:	4e2c      	ldr	r6, [pc, #176]	; (6f40 <xTaskCreate+0x178>)
    6e8e:	3044      	adds	r0, #68	; 0x44
    6e90:	47b0      	blx	r6
    6e92:	0028      	movs	r0, r5
    6e94:	3058      	adds	r0, #88	; 0x58
    6e96:	47b0      	blx	r6
    6e98:	0028      	movs	r0, r5
    6e9a:	306c      	adds	r0, #108	; 0x6c
    6e9c:	47b0      	blx	r6
    6e9e:	0028      	movs	r0, r5
    6ea0:	3080      	adds	r0, #128	; 0x80
    6ea2:	47b0      	blx	r6
    6ea4:	0028      	movs	r0, r5
    6ea6:	3094      	adds	r0, #148	; 0x94
    6ea8:	47b0      	blx	r6
	vListInitialise( &xDelayedTaskList1 );
    6eaa:	4826      	ldr	r0, [pc, #152]	; (6f44 <xTaskCreate+0x17c>)
    6eac:	47b0      	blx	r6
	vListInitialise( &xDelayedTaskList2 );
    6eae:	4826      	ldr	r0, [pc, #152]	; (6f48 <xTaskCreate+0x180>)
    6eb0:	47b0      	blx	r6
	vListInitialise( &xPendingReadyList );
    6eb2:	0038      	movs	r0, r7
    6eb4:	3050      	adds	r0, #80	; 0x50
    6eb6:	47b0      	blx	r6
		vListInitialise( &xTasksWaitingTermination );
    6eb8:	0028      	movs	r0, r5
    6eba:	3028      	adds	r0, #40	; 0x28
    6ebc:	47b0      	blx	r6
		vListInitialise( &xSuspendedTaskList );
    6ebe:	0028      	movs	r0, r5
    6ec0:	3010      	adds	r0, #16
    6ec2:	47b0      	blx	r6
	pxDelayedTaskList = &xDelayedTaskList1;
    6ec4:	4b1f      	ldr	r3, [pc, #124]	; (6f44 <xTaskCreate+0x17c>)
    6ec6:	602b      	str	r3, [r5, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6ec8:	4b1f      	ldr	r3, [pc, #124]	; (6f48 <xTaskCreate+0x180>)
    6eca:	626b      	str	r3, [r5, #36]	; 0x24
		uxTaskNumber++;
    6ecc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
		prvAddTaskToReadyList( pxNewTCB );
    6ece:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
		uxTaskNumber++;
    6ed0:	3301      	adds	r3, #1
    6ed2:	66bb      	str	r3, [r7, #104]	; 0x68
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    6ed4:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    6ed6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    6ed8:	429a      	cmp	r2, r3
    6eda:	d900      	bls.n	6ede <xTaskCreate+0x116>
    6edc:	66fa      	str	r2, [r7, #108]	; 0x6c
    6ede:	2314      	movs	r3, #20
    6ee0:	0028      	movs	r0, r5
    6ee2:	4353      	muls	r3, r2
    6ee4:	3044      	adds	r0, #68	; 0x44
    6ee6:	18c0      	adds	r0, r0, r3
    6ee8:	1d21      	adds	r1, r4, #4
    6eea:	4b18      	ldr	r3, [pc, #96]	; (6f4c <xTaskCreate+0x184>)
    6eec:	4798      	blx	r3
	taskEXIT_CRITICAL();
    6eee:	4b18      	ldr	r3, [pc, #96]	; (6f50 <xTaskCreate+0x188>)
    6ef0:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    6ef2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
			xReturn = pdPASS;
    6ef4:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
    6ef6:	b133      	cbz	r3, 6f06 <xTaskCreate+0x13e>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    6ef8:	68eb      	ldr	r3, [r5, #12]
    6efa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    6efc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    6efe:	429a      	cmp	r2, r3
    6f00:	d201      	bcs.n	6f06 <xTaskCreate+0x13e>
			taskYIELD_IF_USING_PREEMPTION();
    6f02:	4b14      	ldr	r3, [pc, #80]	; (6f54 <xTaskCreate+0x18c>)
    6f04:	4798      	blx	r3
	}
    6f06:	0030      	movs	r0, r6
    6f08:	b005      	add	sp, #20
    6f0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if( xSchedulerRunning == pdFALSE )
    6f0c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    6f0e:	2b00      	cmp	r3, #0
    6f10:	d1dc      	bne.n	6ecc <xTaskCreate+0x104>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    6f12:	68eb      	ldr	r3, [r5, #12]
    6f14:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    6f16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6f18:	4293      	cmp	r3, r2
    6f1a:	d8d7      	bhi.n	6ecc <xTaskCreate+0x104>
					pxCurrentTCB = pxNewTCB;
    6f1c:	60ec      	str	r4, [r5, #12]
    6f1e:	e7d5      	b.n	6ecc <xTaskCreate+0x104>
    6f20:	00007e21 	.word	0x00007e21
    6f24:	00007e81 	.word	0x00007e81
    6f28:	000081f3 	.word	0x000081f3
    6f2c:	00007a8f 	.word	0x00007a8f
    6f30:	00007ee5 	.word	0x00007ee5
    6f34:	20000028 	.word	0x20000028
    6f38:	00007f8d 	.word	0x00007f8d
    6f3c:	200000a8 	.word	0x200000a8
    6f40:	00007a79 	.word	0x00007a79
    6f44:	200000d0 	.word	0x200000d0
    6f48:	200000e4 	.word	0x200000e4
    6f4c:	00007a95 	.word	0x00007a95
    6f50:	00007fa5 	.word	0x00007fa5
    6f54:	00007f75 	.word	0x00007f75

00006f58 <vTaskStartScheduler>:
{
    6f58:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(	prvIdleTask,
    6f5a:	4d10      	ldr	r5, [pc, #64]	; (6f9c <vTaskStartScheduler+0x44>)
    6f5c:	2400      	movs	r4, #0
    6f5e:	002b      	movs	r3, r5
    6f60:	3374      	adds	r3, #116	; 0x74
    6f62:	9301      	str	r3, [sp, #4]
    6f64:	9400      	str	r4, [sp, #0]
    6f66:	0023      	movs	r3, r4
    6f68:	223c      	movs	r2, #60	; 0x3c
    6f6a:	490d      	ldr	r1, [pc, #52]	; (6fa0 <vTaskStartScheduler+0x48>)
    6f6c:	480d      	ldr	r0, [pc, #52]	; (6fa4 <vTaskStartScheduler+0x4c>)
    6f6e:	4e0e      	ldr	r6, [pc, #56]	; (6fa8 <vTaskStartScheduler+0x50>)
    6f70:	47b0      	blx	r6
		if( xReturn == pdPASS )
    6f72:	2801      	cmp	r0, #1
    6f74:	d10d      	bne.n	6f92 <vTaskStartScheduler+0x3a>
			xReturn = xTimerCreateTimerTask();
    6f76:	4b0d      	ldr	r3, [pc, #52]	; (6fac <vTaskStartScheduler+0x54>)
    6f78:	4798      	blx	r3
	if( xReturn == pdPASS )
    6f7a:	2801      	cmp	r0, #1
    6f7c:	d109      	bne.n	6f92 <vTaskStartScheduler+0x3a>
		portDISABLE_INTERRUPTS();
    6f7e:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    6f80:	2201      	movs	r2, #1
    6f82:	4b0b      	ldr	r3, [pc, #44]	; (6fb0 <vTaskStartScheduler+0x58>)
    6f84:	4252      	negs	r2, r2
    6f86:	605a      	str	r2, [r3, #4]
		xSchedulerRunning = pdTRUE;
    6f88:	6668      	str	r0, [r5, #100]	; 0x64
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    6f8a:	609c      	str	r4, [r3, #8]
		if( xPortStartScheduler() != pdFALSE )
    6f8c:	4b09      	ldr	r3, [pc, #36]	; (6fb4 <vTaskStartScheduler+0x5c>)
    6f8e:	4798      	blx	r3
}
    6f90:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    6f92:	1c43      	adds	r3, r0, #1
    6f94:	d1fc      	bne.n	6f90 <vTaskStartScheduler+0x38>
    6f96:	b672      	cpsid	i
    6f98:	e7fe      	b.n	6f98 <vTaskStartScheduler+0x40>
    6f9a:	46c0      	nop			; (mov r8, r8)
    6f9c:	200000a8 	.word	0x200000a8
    6fa0:	00008202 	.word	0x00008202
    6fa4:	00006d71 	.word	0x00006d71
    6fa8:	00006dc9 	.word	0x00006dc9
    6fac:	00007b95 	.word	0x00007b95
    6fb0:	20000028 	.word	0x20000028
    6fb4:	00007f05 	.word	0x00007f05

00006fb8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    6fb8:	4a02      	ldr	r2, [pc, #8]	; (6fc4 <vTaskSuspendAll+0xc>)
    6fba:	6f13      	ldr	r3, [r2, #112]	; 0x70
    6fbc:	3301      	adds	r3, #1
    6fbe:	6713      	str	r3, [r2, #112]	; 0x70
}
    6fc0:	4770      	bx	lr
    6fc2:	46c0      	nop			; (mov r8, r8)
    6fc4:	200000a8 	.word	0x200000a8

00006fc8 <xTaskGetTickCount>:
    6fc8:	4b01      	ldr	r3, [pc, #4]	; (6fd0 <xTaskGetTickCount+0x8>)
    6fca:	6898      	ldr	r0, [r3, #8]
    6fcc:	4770      	bx	lr
    6fce:	46c0      	nop			; (mov r8, r8)
    6fd0:	20000028 	.word	0x20000028

00006fd4 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6fd4:	4b32      	ldr	r3, [pc, #200]	; (70a0 <xTaskIncrementTick+0xcc>)
{
    6fd6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6fd8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    6fda:	001e      	movs	r6, r3
    6fdc:	2a00      	cmp	r2, #0
    6fde:	d158      	bne.n	7092 <xTaskIncrementTick+0xbe>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    6fe0:	4b30      	ldr	r3, [pc, #192]	; (70a4 <xTaskIncrementTick+0xd0>)
    6fe2:	689a      	ldr	r2, [r3, #8]
    6fe4:	001c      	movs	r4, r3
    6fe6:	3201      	adds	r2, #1
    6fe8:	9200      	str	r2, [sp, #0]
		xTickCount = xConstTickCount;
    6fea:	609a      	str	r2, [r3, #8]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    6fec:	b96a      	cbnz	r2, 700a <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
    6fee:	681b      	ldr	r3, [r3, #0]
    6ff0:	681b      	ldr	r3, [r3, #0]
    6ff2:	b10b      	cbz	r3, 6ff8 <xTaskIncrementTick+0x24>
    6ff4:	b672      	cpsid	i
    6ff6:	e7fe      	b.n	6ff6 <xTaskIncrementTick+0x22>
    6ff8:	6823      	ldr	r3, [r4, #0]
    6ffa:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6ffc:	6022      	str	r2, [r4, #0]
    6ffe:	6263      	str	r3, [r4, #36]	; 0x24
    7000:	6fb3      	ldr	r3, [r6, #120]	; 0x78
    7002:	3301      	adds	r3, #1
    7004:	67b3      	str	r3, [r6, #120]	; 0x78
    7006:	4b28      	ldr	r3, [pc, #160]	; (70a8 <xTaskIncrementTick+0xd4>)
    7008:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    700a:	6863      	ldr	r3, [r4, #4]
    700c:	9a00      	ldr	r2, [sp, #0]
BaseType_t xSwitchRequired = pdFALSE;
    700e:	2700      	movs	r7, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
    7010:	429a      	cmp	r2, r3
    7012:	d304      	bcc.n	701e <xTaskIncrementTick+0x4a>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    7014:	6823      	ldr	r3, [r4, #0]
    7016:	681b      	ldr	r3, [r3, #0]
    7018:	b9ab      	cbnz	r3, 7046 <xTaskIncrementTick+0x72>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    701a:	3b01      	subs	r3, #1
						xNextTaskUnblockTime = xItemValue;
    701c:	6063      	str	r3, [r4, #4]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    701e:	68e3      	ldr	r3, [r4, #12]
    7020:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    7022:	2314      	movs	r3, #20
    7024:	4353      	muls	r3, r2
    7026:	4a1f      	ldr	r2, [pc, #124]	; (70a4 <xTaskIncrementTick+0xd0>)
    7028:	189b      	adds	r3, r3, r2
    702a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    702c:	2b01      	cmp	r3, #1
    702e:	d900      	bls.n	7032 <xTaskIncrementTick+0x5e>
				xSwitchRequired = pdTRUE;
    7030:	2701      	movs	r7, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
    7032:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
    7034:	b90b      	cbnz	r3, 703a <xTaskIncrementTick+0x66>
				vApplicationTickHook();
    7036:	4b1d      	ldr	r3, [pc, #116]	; (70ac <xTaskIncrementTick+0xd8>)
    7038:	4798      	blx	r3
		if( xYieldPending != pdFALSE )
    703a:	4b1d      	ldr	r3, [pc, #116]	; (70b0 <xTaskIncrementTick+0xdc>)
    703c:	681b      	ldr	r3, [r3, #0]
    703e:	b103      	cbz	r3, 7042 <xTaskIncrementTick+0x6e>
			xSwitchRequired = pdTRUE;
    7040:	2701      	movs	r7, #1
}
    7042:	0038      	movs	r0, r7
    7044:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7046:	6823      	ldr	r3, [r4, #0]
					if( xConstTickCount < xItemValue )
    7048:	9a00      	ldr	r2, [sp, #0]
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    704a:	68db      	ldr	r3, [r3, #12]
    704c:	68dd      	ldr	r5, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    704e:	686b      	ldr	r3, [r5, #4]
					if( xConstTickCount < xItemValue )
    7050:	429a      	cmp	r2, r3
    7052:	d3e3      	bcc.n	701c <xTaskIncrementTick+0x48>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7054:	1d2b      	adds	r3, r5, #4
    7056:	9301      	str	r3, [sp, #4]
    7058:	0018      	movs	r0, r3
    705a:	4b16      	ldr	r3, [pc, #88]	; (70b4 <xTaskIncrementTick+0xe0>)
    705c:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    705e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7060:	b11b      	cbz	r3, 706a <xTaskIncrementTick+0x96>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    7062:	0028      	movs	r0, r5
    7064:	4b13      	ldr	r3, [pc, #76]	; (70b4 <xTaskIncrementTick+0xe0>)
    7066:	3018      	adds	r0, #24
    7068:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    706a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    706c:	6ef2      	ldr	r2, [r6, #108]	; 0x6c
    706e:	4293      	cmp	r3, r2
    7070:	d900      	bls.n	7074 <xTaskIncrementTick+0xa0>
    7072:	66f3      	str	r3, [r6, #108]	; 0x6c
    7074:	2214      	movs	r2, #20
    7076:	0020      	movs	r0, r4
    7078:	4353      	muls	r3, r2
    707a:	3044      	adds	r0, #68	; 0x44
    707c:	18c0      	adds	r0, r0, r3
    707e:	1d29      	adds	r1, r5, #4
    7080:	4b0d      	ldr	r3, [pc, #52]	; (70b8 <xTaskIncrementTick+0xe4>)
    7082:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7084:	68e3      	ldr	r3, [r4, #12]
    7086:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    7088:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    708a:	429a      	cmp	r2, r3
    708c:	d3c2      	bcc.n	7014 <xTaskIncrementTick+0x40>
							xSwitchRequired = pdTRUE;
    708e:	2701      	movs	r7, #1
    7090:	e7c0      	b.n	7014 <xTaskIncrementTick+0x40>
		++uxPendedTicks;
    7092:	6fda      	ldr	r2, [r3, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    7094:	2700      	movs	r7, #0
		++uxPendedTicks;
    7096:	3201      	adds	r2, #1
    7098:	67da      	str	r2, [r3, #124]	; 0x7c
			vApplicationTickHook();
    709a:	4b04      	ldr	r3, [pc, #16]	; (70ac <xTaskIncrementTick+0xd8>)
    709c:	4798      	blx	r3
    709e:	e7cc      	b.n	703a <xTaskIncrementTick+0x66>
    70a0:	200000a8 	.word	0x200000a8
    70a4:	20000028 	.word	0x20000028
    70a8:	00006cf5 	.word	0x00006cf5
    70ac:	000080b5 	.word	0x000080b5
    70b0:	20000128 	.word	0x20000128
    70b4:	00007adb 	.word	0x00007adb
    70b8:	00007a95 	.word	0x00007a95

000070bc <xTaskResumeAll>:
{
    70bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
    70be:	4c27      	ldr	r4, [pc, #156]	; (715c <xTaskResumeAll+0xa0>)
    70c0:	6f23      	ldr	r3, [r4, #112]	; 0x70
    70c2:	b90b      	cbnz	r3, 70c8 <xTaskResumeAll+0xc>
    70c4:	b672      	cpsid	i
    70c6:	e7fe      	b.n	70c6 <xTaskResumeAll+0xa>
	taskENTER_CRITICAL();
    70c8:	4b25      	ldr	r3, [pc, #148]	; (7160 <xTaskResumeAll+0xa4>)
    70ca:	4798      	blx	r3
		--uxSchedulerSuspended;
    70cc:	6f23      	ldr	r3, [r4, #112]	; 0x70
    70ce:	3b01      	subs	r3, #1
    70d0:	6723      	str	r3, [r4, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    70d2:	6f25      	ldr	r5, [r4, #112]	; 0x70
    70d4:	b125      	cbz	r5, 70e0 <xTaskResumeAll+0x24>
BaseType_t xAlreadyYielded = pdFALSE;
    70d6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    70d8:	4b22      	ldr	r3, [pc, #136]	; (7164 <xTaskResumeAll+0xa8>)
    70da:	4798      	blx	r3
}
    70dc:	0020      	movs	r0, r4
    70de:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    70e0:	4e21      	ldr	r6, [pc, #132]	; (7168 <xTaskResumeAll+0xac>)
    70e2:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    70e4:	2b00      	cmp	r3, #0
    70e6:	d0f6      	beq.n	70d6 <xTaskResumeAll+0x1a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    70e8:	6d23      	ldr	r3, [r4, #80]	; 0x50
    70ea:	b9b3      	cbnz	r3, 711a <xTaskResumeAll+0x5e>
				if( pxTCB != NULL )
    70ec:	b10d      	cbz	r5, 70f2 <xTaskResumeAll+0x36>
					prvResetNextTaskUnblockTime();
    70ee:	4b1f      	ldr	r3, [pc, #124]	; (716c <xTaskResumeAll+0xb0>)
    70f0:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    70f2:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    70f4:	b14d      	cbz	r5, 710a <xTaskResumeAll+0x4e>
								xYieldPending = pdTRUE;
    70f6:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
    70f8:	4b1d      	ldr	r3, [pc, #116]	; (7170 <xTaskResumeAll+0xb4>)
    70fa:	4798      	blx	r3
    70fc:	b108      	cbz	r0, 7102 <xTaskResumeAll+0x46>
								xYieldPending = pdTRUE;
    70fe:	4b1d      	ldr	r3, [pc, #116]	; (7174 <xTaskResumeAll+0xb8>)
    7100:	601e      	str	r6, [r3, #0]
							--uxPendedCounts;
    7102:	3d01      	subs	r5, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    7104:	2d00      	cmp	r5, #0
    7106:	d1f7      	bne.n	70f8 <xTaskResumeAll+0x3c>
						uxPendedTicks = 0;
    7108:	67e5      	str	r5, [r4, #124]	; 0x7c
				if( xYieldPending != pdFALSE )
    710a:	4b1a      	ldr	r3, [pc, #104]	; (7174 <xTaskResumeAll+0xb8>)
    710c:	681b      	ldr	r3, [r3, #0]
    710e:	2b00      	cmp	r3, #0
    7110:	d0e1      	beq.n	70d6 <xTaskResumeAll+0x1a>
					taskYIELD_IF_USING_PREEMPTION();
    7112:	4b19      	ldr	r3, [pc, #100]	; (7178 <xTaskResumeAll+0xbc>)
    7114:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    7116:	2401      	movs	r4, #1
    7118:	e7de      	b.n	70d8 <xTaskResumeAll+0x1c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    711a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    711c:	4f17      	ldr	r7, [pc, #92]	; (717c <xTaskResumeAll+0xc0>)
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    711e:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    7120:	0028      	movs	r0, r5
    7122:	3018      	adds	r0, #24
    7124:	47b8      	blx	r7
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7126:	1d2b      	adds	r3, r5, #4
    7128:	0018      	movs	r0, r3
    712a:	9301      	str	r3, [sp, #4]
    712c:	47b8      	blx	r7
					prvAddTaskToReadyList( pxTCB );
    712e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    7130:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    7132:	4293      	cmp	r3, r2
    7134:	d900      	bls.n	7138 <xTaskResumeAll+0x7c>
    7136:	66e3      	str	r3, [r4, #108]	; 0x6c
    7138:	2214      	movs	r2, #20
    713a:	0030      	movs	r0, r6
    713c:	4353      	muls	r3, r2
    713e:	3044      	adds	r0, #68	; 0x44
    7140:	18c0      	adds	r0, r0, r3
    7142:	1d29      	adds	r1, r5, #4
    7144:	4b0e      	ldr	r3, [pc, #56]	; (7180 <xTaskResumeAll+0xc4>)
    7146:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7148:	68f3      	ldr	r3, [r6, #12]
    714a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    714c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    714e:	429a      	cmp	r2, r3
    7150:	d3ca      	bcc.n	70e8 <xTaskResumeAll+0x2c>
						xYieldPending = pdTRUE;
    7152:	2201      	movs	r2, #1
    7154:	4b07      	ldr	r3, [pc, #28]	; (7174 <xTaskResumeAll+0xb8>)
    7156:	601a      	str	r2, [r3, #0]
    7158:	e7c6      	b.n	70e8 <xTaskResumeAll+0x2c>
    715a:	46c0      	nop			; (mov r8, r8)
    715c:	200000a8 	.word	0x200000a8
    7160:	00007f8d 	.word	0x00007f8d
    7164:	00007fa5 	.word	0x00007fa5
    7168:	20000028 	.word	0x20000028
    716c:	00006cf5 	.word	0x00006cf5
    7170:	00006fd5 	.word	0x00006fd5
    7174:	20000128 	.word	0x20000128
    7178:	00007f75 	.word	0x00007f75
    717c:	00007adb 	.word	0x00007adb
    7180:	00007a95 	.word	0x00007a95

00007184 <vTaskDelayUntil>:
	{
    7184:	b570      	push	{r4, r5, r6, lr}
    7186:	0005      	movs	r5, r0
    7188:	000c      	movs	r4, r1
		configASSERT( pxPreviousWakeTime );
    718a:	b908      	cbnz	r0, 7190 <vTaskDelayUntil+0xc>
    718c:	b672      	cpsid	i
    718e:	e7fe      	b.n	718e <vTaskDelayUntil+0xa>
		configASSERT( ( xTimeIncrement > 0U ) );
    7190:	b909      	cbnz	r1, 7196 <vTaskDelayUntil+0x12>
    7192:	b672      	cpsid	i
    7194:	e7fe      	b.n	7194 <vTaskDelayUntil+0x10>
		configASSERT( uxSchedulerSuspended == 0 );
    7196:	4b11      	ldr	r3, [pc, #68]	; (71dc <vTaskDelayUntil+0x58>)
    7198:	6f1e      	ldr	r6, [r3, #112]	; 0x70
    719a:	b10e      	cbz	r6, 71a0 <vTaskDelayUntil+0x1c>
    719c:	b672      	cpsid	i
    719e:	e7fe      	b.n	719e <vTaskDelayUntil+0x1a>
		vTaskSuspendAll();
    71a0:	4b0f      	ldr	r3, [pc, #60]	; (71e0 <vTaskDelayUntil+0x5c>)
    71a2:	4798      	blx	r3
			const TickType_t xConstTickCount = xTickCount;
    71a4:	4b0f      	ldr	r3, [pc, #60]	; (71e4 <vTaskDelayUntil+0x60>)
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    71a6:	682a      	ldr	r2, [r5, #0]
			const TickType_t xConstTickCount = xTickCount;
    71a8:	6898      	ldr	r0, [r3, #8]
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    71aa:	18a4      	adds	r4, r4, r2
			if( xConstTickCount < *pxPreviousWakeTime )
    71ac:	4290      	cmp	r0, r2
    71ae:	d205      	bcs.n	71bc <vTaskDelayUntil+0x38>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    71b0:	42a2      	cmp	r2, r4
    71b2:	d906      	bls.n	71c2 <vTaskDelayUntil+0x3e>
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    71b4:	42a0      	cmp	r0, r4
    71b6:	41b6      	sbcs	r6, r6
    71b8:	4276      	negs	r6, r6
    71ba:	e002      	b.n	71c2 <vTaskDelayUntil+0x3e>
					xShouldDelay = pdTRUE;
    71bc:	2601      	movs	r6, #1
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    71be:	42a2      	cmp	r2, r4
    71c0:	d9f8      	bls.n	71b4 <vTaskDelayUntil+0x30>
			*pxPreviousWakeTime = xTimeToWake;
    71c2:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
    71c4:	b11e      	cbz	r6, 71ce <vTaskDelayUntil+0x4a>
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    71c6:	1a20      	subs	r0, r4, r0
    71c8:	2100      	movs	r1, #0
    71ca:	4b07      	ldr	r3, [pc, #28]	; (71e8 <vTaskDelayUntil+0x64>)
    71cc:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    71ce:	4b07      	ldr	r3, [pc, #28]	; (71ec <vTaskDelayUntil+0x68>)
    71d0:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
    71d2:	b908      	cbnz	r0, 71d8 <vTaskDelayUntil+0x54>
			portYIELD_WITHIN_API();
    71d4:	4b06      	ldr	r3, [pc, #24]	; (71f0 <vTaskDelayUntil+0x6c>)
    71d6:	4798      	blx	r3
	}
    71d8:	bd70      	pop	{r4, r5, r6, pc}
    71da:	46c0      	nop			; (mov r8, r8)
    71dc:	200000a8 	.word	0x200000a8
    71e0:	00006fb9 	.word	0x00006fb9
    71e4:	20000028 	.word	0x20000028
    71e8:	00006d11 	.word	0x00006d11
    71ec:	000070bd 	.word	0x000070bd
    71f0:	00007f75 	.word	0x00007f75

000071f4 <vTaskSwitchContext>:
{
    71f4:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    71f6:	4d1e      	ldr	r5, [pc, #120]	; (7270 <vTaskSwitchContext+0x7c>)
    71f8:	4b1e      	ldr	r3, [pc, #120]	; (7274 <vTaskSwitchContext+0x80>)
    71fa:	6f2a      	ldr	r2, [r5, #112]	; 0x70
    71fc:	b112      	cbz	r2, 7204 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
    71fe:	2201      	movs	r2, #1
    7200:	601a      	str	r2, [r3, #0]
}
    7202:	bd70      	pop	{r4, r5, r6, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
    7204:	4c1c      	ldr	r4, [pc, #112]	; (7278 <vTaskSwitchContext+0x84>)
		xYieldPending = pdFALSE;
    7206:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
    7208:	68e3      	ldr	r3, [r4, #12]
    720a:	491c      	ldr	r1, [pc, #112]	; (727c <vTaskSwitchContext+0x88>)
    720c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    720e:	681a      	ldr	r2, [r3, #0]
    7210:	428a      	cmp	r2, r1
    7212:	d108      	bne.n	7226 <vTaskSwitchContext+0x32>
    7214:	6859      	ldr	r1, [r3, #4]
    7216:	4291      	cmp	r1, r2
    7218:	d105      	bne.n	7226 <vTaskSwitchContext+0x32>
    721a:	689a      	ldr	r2, [r3, #8]
    721c:	428a      	cmp	r2, r1
    721e:	d102      	bne.n	7226 <vTaskSwitchContext+0x32>
    7220:	68db      	ldr	r3, [r3, #12]
    7222:	4293      	cmp	r3, r2
    7224:	d004      	beq.n	7230 <vTaskSwitchContext+0x3c>
    7226:	68e0      	ldr	r0, [r4, #12]
    7228:	68e1      	ldr	r1, [r4, #12]
    722a:	4b15      	ldr	r3, [pc, #84]	; (7280 <vTaskSwitchContext+0x8c>)
    722c:	3134      	adds	r1, #52	; 0x34
    722e:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7230:	2614      	movs	r6, #20
    7232:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
    7234:	0032      	movs	r2, r6
    7236:	435a      	muls	r2, r3
    7238:	490f      	ldr	r1, [pc, #60]	; (7278 <vTaskSwitchContext+0x84>)
    723a:	1851      	adds	r1, r2, r1
    723c:	6c48      	ldr	r0, [r1, #68]	; 0x44
    723e:	b188      	cbz	r0, 7264 <vTaskSwitchContext+0x70>
    7240:	6c88      	ldr	r0, [r1, #72]	; 0x48
    7242:	18a2      	adds	r2, r4, r2
    7244:	6840      	ldr	r0, [r0, #4]
    7246:	324c      	adds	r2, #76	; 0x4c
    7248:	6488      	str	r0, [r1, #72]	; 0x48
    724a:	4290      	cmp	r0, r2
    724c:	d101      	bne.n	7252 <vTaskSwitchContext+0x5e>
    724e:	6842      	ldr	r2, [r0, #4]
    7250:	648a      	str	r2, [r1, #72]	; 0x48
    7252:	2214      	movs	r2, #20
    7254:	435a      	muls	r2, r3
    7256:	4908      	ldr	r1, [pc, #32]	; (7278 <vTaskSwitchContext+0x84>)
    7258:	1852      	adds	r2, r2, r1
    725a:	6c92      	ldr	r2, [r2, #72]	; 0x48
    725c:	68d2      	ldr	r2, [r2, #12]
    725e:	60e2      	str	r2, [r4, #12]
    7260:	66eb      	str	r3, [r5, #108]	; 0x6c
}
    7262:	e7ce      	b.n	7202 <vTaskSwitchContext+0xe>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7264:	b90b      	cbnz	r3, 726a <vTaskSwitchContext+0x76>
    7266:	b672      	cpsid	i
    7268:	e7fe      	b.n	7268 <vTaskSwitchContext+0x74>
    726a:	3b01      	subs	r3, #1
    726c:	e7e2      	b.n	7234 <vTaskSwitchContext+0x40>
    726e:	46c0      	nop			; (mov r8, r8)
    7270:	200000a8 	.word	0x200000a8
    7274:	20000128 	.word	0x20000128
    7278:	20000028 	.word	0x20000028
    727c:	a5a5a5a5 	.word	0xa5a5a5a5
    7280:	000080b1 	.word	0x000080b1

00007284 <vTaskPlaceOnEventList>:
{
    7284:	b510      	push	{r4, lr}
    7286:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    7288:	b908      	cbnz	r0, 728e <vTaskPlaceOnEventList+0xa>
    728a:	b672      	cpsid	i
    728c:	e7fe      	b.n	728c <vTaskPlaceOnEventList+0x8>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    728e:	4b05      	ldr	r3, [pc, #20]	; (72a4 <vTaskPlaceOnEventList+0x20>)
    7290:	68d9      	ldr	r1, [r3, #12]
    7292:	4b05      	ldr	r3, [pc, #20]	; (72a8 <vTaskPlaceOnEventList+0x24>)
    7294:	3118      	adds	r1, #24
    7296:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7298:	2101      	movs	r1, #1
    729a:	0020      	movs	r0, r4
    729c:	4b03      	ldr	r3, [pc, #12]	; (72ac <vTaskPlaceOnEventList+0x28>)
    729e:	4798      	blx	r3
}
    72a0:	bd10      	pop	{r4, pc}
    72a2:	46c0      	nop			; (mov r8, r8)
    72a4:	20000028 	.word	0x20000028
    72a8:	00007aad 	.word	0x00007aad
    72ac:	00006d11 	.word	0x00006d11

000072b0 <vTaskPlaceOnEventListRestricted>:
	{
    72b0:	b570      	push	{r4, r5, r6, lr}
    72b2:	000c      	movs	r4, r1
    72b4:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    72b6:	b908      	cbnz	r0, 72bc <vTaskPlaceOnEventListRestricted+0xc>
    72b8:	b672      	cpsid	i
    72ba:	e7fe      	b.n	72ba <vTaskPlaceOnEventListRestricted+0xa>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    72bc:	4b06      	ldr	r3, [pc, #24]	; (72d8 <vTaskPlaceOnEventListRestricted+0x28>)
    72be:	68d9      	ldr	r1, [r3, #12]
    72c0:	4b06      	ldr	r3, [pc, #24]	; (72dc <vTaskPlaceOnEventListRestricted+0x2c>)
    72c2:	3118      	adds	r1, #24
    72c4:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    72c6:	b10d      	cbz	r5, 72cc <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    72c8:	2401      	movs	r4, #1
    72ca:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    72cc:	0029      	movs	r1, r5
    72ce:	0020      	movs	r0, r4
    72d0:	4b03      	ldr	r3, [pc, #12]	; (72e0 <vTaskPlaceOnEventListRestricted+0x30>)
    72d2:	4798      	blx	r3
	}
    72d4:	bd70      	pop	{r4, r5, r6, pc}
    72d6:	46c0      	nop			; (mov r8, r8)
    72d8:	20000028 	.word	0x20000028
    72dc:	00007a95 	.word	0x00007a95
    72e0:	00006d11 	.word	0x00006d11

000072e4 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    72e4:	68c3      	ldr	r3, [r0, #12]
{
    72e6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    72e8:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
    72ea:	b90d      	cbnz	r5, 72f0 <xTaskRemoveFromEventList+0xc>
    72ec:	b672      	cpsid	i
    72ee:	e7fe      	b.n	72ee <xTaskRemoveFromEventList+0xa>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    72f0:	002b      	movs	r3, r5
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    72f2:	4c14      	ldr	r4, [pc, #80]	; (7344 <xTaskRemoveFromEventList+0x60>)
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    72f4:	3318      	adds	r3, #24
    72f6:	0018      	movs	r0, r3
    72f8:	4f13      	ldr	r7, [pc, #76]	; (7348 <xTaskRemoveFromEventList+0x64>)
    72fa:	9301      	str	r3, [sp, #4]
    72fc:	47b8      	blx	r7
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    72fe:	6f23      	ldr	r3, [r4, #112]	; 0x70
    7300:	4e12      	ldr	r6, [pc, #72]	; (734c <xTaskRemoveFromEventList+0x68>)
    7302:	b9d3      	cbnz	r3, 733a <xTaskRemoveFromEventList+0x56>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    7304:	1d2b      	adds	r3, r5, #4
    7306:	0018      	movs	r0, r3
    7308:	9301      	str	r3, [sp, #4]
    730a:	47b8      	blx	r7
		prvAddTaskToReadyList( pxUnblockedTCB );
    730c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    730e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    7310:	429a      	cmp	r2, r3
    7312:	d900      	bls.n	7316 <xTaskRemoveFromEventList+0x32>
    7314:	66e2      	str	r2, [r4, #108]	; 0x6c
    7316:	2314      	movs	r3, #20
    7318:	0030      	movs	r0, r6
    731a:	4353      	muls	r3, r2
    731c:	3044      	adds	r0, #68	; 0x44
    731e:	18c0      	adds	r0, r0, r3
    7320:	1d29      	adds	r1, r5, #4
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    7322:	4b0b      	ldr	r3, [pc, #44]	; (7350 <xTaskRemoveFromEventList+0x6c>)
    7324:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    7326:	68f3      	ldr	r3, [r6, #12]
    7328:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    732a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    732c:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    732e:	429a      	cmp	r2, r3
    7330:	d902      	bls.n	7338 <xTaskRemoveFromEventList+0x54>
		xYieldPending = pdTRUE;
    7332:	4b08      	ldr	r3, [pc, #32]	; (7354 <xTaskRemoveFromEventList+0x70>)
    7334:	3001      	adds	r0, #1
    7336:	6018      	str	r0, [r3, #0]
}
    7338:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    733a:	0020      	movs	r0, r4
    733c:	9901      	ldr	r1, [sp, #4]
    733e:	3050      	adds	r0, #80	; 0x50
    7340:	e7ef      	b.n	7322 <xTaskRemoveFromEventList+0x3e>
    7342:	46c0      	nop			; (mov r8, r8)
    7344:	200000a8 	.word	0x200000a8
    7348:	00007adb 	.word	0x00007adb
    734c:	20000028 	.word	0x20000028
    7350:	00007a95 	.word	0x00007a95
    7354:	20000128 	.word	0x20000128

00007358 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    7358:	4b03      	ldr	r3, [pc, #12]	; (7368 <vTaskInternalSetTimeOutState+0x10>)
    735a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    735c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    735e:	4b03      	ldr	r3, [pc, #12]	; (736c <vTaskInternalSetTimeOutState+0x14>)
    7360:	689b      	ldr	r3, [r3, #8]
    7362:	6043      	str	r3, [r0, #4]
}
    7364:	4770      	bx	lr
    7366:	46c0      	nop			; (mov r8, r8)
    7368:	200000a8 	.word	0x200000a8
    736c:	20000028 	.word	0x20000028

00007370 <xTaskCheckForTimeOut>:
{
    7370:	b570      	push	{r4, r5, r6, lr}
    7372:	0005      	movs	r5, r0
    7374:	000c      	movs	r4, r1
	configASSERT( pxTimeOut );
    7376:	b908      	cbnz	r0, 737c <xTaskCheckForTimeOut+0xc>
    7378:	b672      	cpsid	i
    737a:	e7fe      	b.n	737a <xTaskCheckForTimeOut+0xa>
	configASSERT( pxTicksToWait );
    737c:	b909      	cbnz	r1, 7382 <xTaskCheckForTimeOut+0x12>
    737e:	b672      	cpsid	i
    7380:	e7fe      	b.n	7380 <xTaskCheckForTimeOut+0x10>
	taskENTER_CRITICAL();
    7382:	4b11      	ldr	r3, [pc, #68]	; (73c8 <xTaskCheckForTimeOut+0x58>)
    7384:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    7386:	4b11      	ldr	r3, [pc, #68]	; (73cc <xTaskCheckForTimeOut+0x5c>)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    7388:	6869      	ldr	r1, [r5, #4]
		const TickType_t xConstTickCount = xTickCount;
    738a:	689a      	ldr	r2, [r3, #8]
			if( *pxTicksToWait == portMAX_DELAY )
    738c:	6823      	ldr	r3, [r4, #0]
				xReturn = pdFALSE;
    738e:	2600      	movs	r6, #0
			if( *pxTicksToWait == portMAX_DELAY )
    7390:	1c58      	adds	r0, r3, #1
    7392:	d010      	beq.n	73b6 <xTaskCheckForTimeOut+0x46>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    7394:	480e      	ldr	r0, [pc, #56]	; (73d0 <xTaskCheckForTimeOut+0x60>)
    7396:	682e      	ldr	r6, [r5, #0]
    7398:	6f80      	ldr	r0, [r0, #120]	; 0x78
    739a:	4286      	cmp	r6, r0
    739c:	d002      	beq.n	73a4 <xTaskCheckForTimeOut+0x34>
			xReturn = pdTRUE;
    739e:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    73a0:	428a      	cmp	r2, r1
    73a2:	d208      	bcs.n	73b6 <xTaskCheckForTimeOut+0x46>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    73a4:	1a52      	subs	r2, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    73a6:	429a      	cmp	r2, r3
    73a8:	d209      	bcs.n	73be <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= xElapsedTime;
    73aa:	1a9b      	subs	r3, r3, r2
    73ac:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    73ae:	0028      	movs	r0, r5
    73b0:	4b08      	ldr	r3, [pc, #32]	; (73d4 <xTaskCheckForTimeOut+0x64>)
    73b2:	4798      	blx	r3
			xReturn = pdFALSE;
    73b4:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
    73b6:	4b08      	ldr	r3, [pc, #32]	; (73d8 <xTaskCheckForTimeOut+0x68>)
    73b8:	4798      	blx	r3
}
    73ba:	0030      	movs	r0, r6
    73bc:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
    73be:	2300      	movs	r3, #0
			xReturn = pdTRUE;
    73c0:	2601      	movs	r6, #1
			*pxTicksToWait = 0;
    73c2:	6023      	str	r3, [r4, #0]
    73c4:	e7f7      	b.n	73b6 <xTaskCheckForTimeOut+0x46>
    73c6:	46c0      	nop			; (mov r8, r8)
    73c8:	00007f8d 	.word	0x00007f8d
    73cc:	20000028 	.word	0x20000028
    73d0:	200000a8 	.word	0x200000a8
    73d4:	00007359 	.word	0x00007359
    73d8:	00007fa5 	.word	0x00007fa5

000073dc <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    73dc:	2201      	movs	r2, #1
    73de:	4b01      	ldr	r3, [pc, #4]	; (73e4 <vTaskMissedYield+0x8>)
    73e0:	601a      	str	r2, [r3, #0]
}
    73e2:	4770      	bx	lr
    73e4:	20000128 	.word	0x20000128

000073e8 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    73e8:	4b04      	ldr	r3, [pc, #16]	; (73fc <xTaskGetSchedulerState+0x14>)
			xReturn = taskSCHEDULER_NOT_STARTED;
    73ea:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
    73ec:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    73ee:	b11a      	cbz	r2, 73f8 <xTaskGetSchedulerState+0x10>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    73f0:	6f18      	ldr	r0, [r3, #112]	; 0x70
				xReturn = taskSCHEDULER_SUSPENDED;
    73f2:	4243      	negs	r3, r0
    73f4:	4158      	adcs	r0, r3
    73f6:	0040      	lsls	r0, r0, #1
	}
    73f8:	4770      	bx	lr
    73fa:	46c0      	nop			; (mov r8, r8)
    73fc:	200000a8 	.word	0x200000a8

00007400 <xTaskPriorityDisinherit>:
	{
    7400:	b570      	push	{r4, r5, r6, lr}
    7402:	0004      	movs	r4, r0
		if( pxMutexHolder != NULL )
    7404:	b908      	cbnz	r0, 740a <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
    7406:	2000      	movs	r0, #0
	}
    7408:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( pxTCB == pxCurrentTCB );
    740a:	4d15      	ldr	r5, [pc, #84]	; (7460 <xTaskPriorityDisinherit+0x60>)
    740c:	68eb      	ldr	r3, [r5, #12]
    740e:	4298      	cmp	r0, r3
    7410:	d001      	beq.n	7416 <xTaskPriorityDisinherit+0x16>
    7412:	b672      	cpsid	i
    7414:	e7fe      	b.n	7414 <xTaskPriorityDisinherit+0x14>
			configASSERT( pxTCB->uxMutexesHeld );
    7416:	6c83      	ldr	r3, [r0, #72]	; 0x48
    7418:	b90b      	cbnz	r3, 741e <xTaskPriorityDisinherit+0x1e>
    741a:	b672      	cpsid	i
    741c:	e7fe      	b.n	741c <xTaskPriorityDisinherit+0x1c>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    741e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    7420:	6c41      	ldr	r1, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
    7422:	3b01      	subs	r3, #1
    7424:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    7426:	428a      	cmp	r2, r1
    7428:	d0ed      	beq.n	7406 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    742a:	2b00      	cmp	r3, #0
    742c:	d1eb      	bne.n	7406 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    742e:	1d06      	adds	r6, r0, #4
    7430:	4b0c      	ldr	r3, [pc, #48]	; (7464 <xTaskPriorityDisinherit+0x64>)
    7432:	0030      	movs	r0, r6
    7434:	4798      	blx	r3
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7436:	2205      	movs	r2, #5
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    7438:	6c63      	ldr	r3, [r4, #68]	; 0x44
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    743a:	1ad2      	subs	r2, r2, r3
    743c:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    743e:	4a0a      	ldr	r2, [pc, #40]	; (7468 <xTaskPriorityDisinherit+0x68>)
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    7440:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
    7442:	6ed1      	ldr	r1, [r2, #108]	; 0x6c
    7444:	428b      	cmp	r3, r1
    7446:	d900      	bls.n	744a <xTaskPriorityDisinherit+0x4a>
    7448:	66d3      	str	r3, [r2, #108]	; 0x6c
    744a:	0028      	movs	r0, r5
    744c:	2514      	movs	r5, #20
    744e:	436b      	muls	r3, r5
    7450:	3044      	adds	r0, #68	; 0x44
    7452:	18c0      	adds	r0, r0, r3
    7454:	0031      	movs	r1, r6
    7456:	4b05      	ldr	r3, [pc, #20]	; (746c <xTaskPriorityDisinherit+0x6c>)
    7458:	4798      	blx	r3
					xReturn = pdTRUE;
    745a:	2001      	movs	r0, #1
		return xReturn;
    745c:	e7d4      	b.n	7408 <xTaskPriorityDisinherit+0x8>
    745e:	46c0      	nop			; (mov r8, r8)
    7460:	20000028 	.word	0x20000028
    7464:	00007adb 	.word	0x00007adb
    7468:	200000a8 	.word	0x200000a8
    746c:	00007a95 	.word	0x00007a95

00007470 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    7470:	b510      	push	{r4, lr}
    7472:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
    7474:	4b03      	ldr	r3, [pc, #12]	; (7484 <prvIsQueueEmpty+0x14>)
    7476:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    7478:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    747a:	4b03      	ldr	r3, [pc, #12]	; (7488 <prvIsQueueEmpty+0x18>)
    747c:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    747e:	4260      	negs	r0, r4
    7480:	4160      	adcs	r0, r4

	return xReturn;
}
    7482:	bd10      	pop	{r4, pc}
    7484:	00007f8d 	.word	0x00007f8d
    7488:	00007fa5 	.word	0x00007fa5

0000748c <prvCopyDataToQueue>:
{
    748c:	b570      	push	{r4, r5, r6, lr}
    748e:	0016      	movs	r6, r2
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    7490:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
    7492:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    7494:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    7496:	b94a      	cbnz	r2, 74ac <prvCopyDataToQueue+0x20>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    7498:	6806      	ldr	r6, [r0, #0]
BaseType_t xReturn = pdFALSE;
    749a:	0010      	movs	r0, r2
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    749c:	b91e      	cbnz	r6, 74a6 <prvCopyDataToQueue+0x1a>
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    749e:	68a0      	ldr	r0, [r4, #8]
    74a0:	4b14      	ldr	r3, [pc, #80]	; (74f4 <prvCopyDataToQueue+0x68>)
    74a2:	4798      	blx	r3
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    74a4:	60a6      	str	r6, [r4, #8]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    74a6:	3501      	adds	r5, #1
    74a8:	63a5      	str	r5, [r4, #56]	; 0x38
}
    74aa:	bd70      	pop	{r4, r5, r6, pc}
    74ac:	4b12      	ldr	r3, [pc, #72]	; (74f8 <prvCopyDataToQueue+0x6c>)
	else if( xPosition == queueSEND_TO_BACK )
    74ae:	b966      	cbnz	r6, 74ca <prvCopyDataToQueue+0x3e>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    74b0:	6840      	ldr	r0, [r0, #4]
    74b2:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    74b4:	6863      	ldr	r3, [r4, #4]
    74b6:	6c22      	ldr	r2, [r4, #64]	; 0x40
BaseType_t xReturn = pdFALSE;
    74b8:	0030      	movs	r0, r6
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    74ba:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    74bc:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    74be:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    74c0:	4293      	cmp	r3, r2
    74c2:	d3f0      	bcc.n	74a6 <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    74c4:	6823      	ldr	r3, [r4, #0]
    74c6:	6063      	str	r3, [r4, #4]
    74c8:	e7ed      	b.n	74a6 <prvCopyDataToQueue+0x1a>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    74ca:	68c0      	ldr	r0, [r0, #12]
    74cc:	4798      	blx	r3
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    74ce:	6c23      	ldr	r3, [r4, #64]	; 0x40
    74d0:	68e2      	ldr	r2, [r4, #12]
    74d2:	425b      	negs	r3, r3
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    74d4:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    74d6:	18d2      	adds	r2, r2, r3
    74d8:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    74da:	428a      	cmp	r2, r1
    74dc:	d202      	bcs.n	74e4 <prvCopyDataToQueue+0x58>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    74de:	68a2      	ldr	r2, [r4, #8]
    74e0:	18d3      	adds	r3, r2, r3
    74e2:	60e3      	str	r3, [r4, #12]
BaseType_t xReturn = pdFALSE;
    74e4:	2000      	movs	r0, #0
		if( xPosition == queueOVERWRITE )
    74e6:	2e02      	cmp	r6, #2
    74e8:	d1dd      	bne.n	74a6 <prvCopyDataToQueue+0x1a>
				--uxMessagesWaiting;
    74ea:	002b      	movs	r3, r5
    74ec:	1e5a      	subs	r2, r3, #1
    74ee:	4193      	sbcs	r3, r2
    74f0:	1aed      	subs	r5, r5, r3
    74f2:	e7d8      	b.n	74a6 <prvCopyDataToQueue+0x1a>
    74f4:	00007401 	.word	0x00007401
    74f8:	000081e1 	.word	0x000081e1

000074fc <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
    74fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    74fe:	6c84      	ldr	r4, [r0, #72]	; 0x48
	{
    7500:	9001      	str	r0, [sp, #4]
    7502:	000a      	movs	r2, r1
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
    7504:	b90c      	cbnz	r4, 750a <prvNotifyQueueSetContainer+0xe>
    7506:	b672      	cpsid	i
    7508:	e7fe      	b.n	7508 <prvNotifyQueueSetContainer+0xc>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
    750a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    750c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    750e:	4299      	cmp	r1, r3
    7510:	d301      	bcc.n	7516 <prvNotifyQueueSetContainer+0x1a>
    7512:	b672      	cpsid	i
    7514:	e7fe      	b.n	7514 <prvNotifyQueueSetContainer+0x18>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    7516:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn = pdFALSE;
    7518:	2600      	movs	r6, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    751a:	428b      	cmp	r3, r1
    751c:	d912      	bls.n	7544 <prvNotifyQueueSetContainer+0x48>
		{
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    751e:	0027      	movs	r7, r4

			traceQUEUE_SEND( pxQueueSetContainer );

			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    7520:	a901      	add	r1, sp, #4
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    7522:	3745      	adds	r7, #69	; 0x45
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    7524:	0020      	movs	r0, r4
    7526:	4b0a      	ldr	r3, [pc, #40]	; (7550 <prvNotifyQueueSetContainer+0x54>)
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    7528:	783d      	ldrb	r5, [r7, #0]
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    752a:	4798      	blx	r3
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    752c:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    752e:	0006      	movs	r6, r0

			if( cTxLock == queueUNLOCKED )
    7530:	1c6b      	adds	r3, r5, #1
    7532:	d109      	bne.n	7548 <prvNotifyQueueSetContainer+0x4c>
			{
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
    7534:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7536:	b12b      	cbz	r3, 7544 <prvNotifyQueueSetContainer+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
    7538:	0020      	movs	r0, r4
    753a:	4b06      	ldr	r3, [pc, #24]	; (7554 <prvNotifyQueueSetContainer+0x58>)
    753c:	3024      	adds	r0, #36	; 0x24
    753e:	4798      	blx	r3
    7540:	b100      	cbz	r0, 7544 <prvNotifyQueueSetContainer+0x48>
					{
						/* The task waiting has a higher priority. */
						xReturn = pdTRUE;
    7542:	2601      	movs	r6, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    7544:	0030      	movs	r0, r6
    7546:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
    7548:	3501      	adds	r5, #1
    754a:	b26d      	sxtb	r5, r5
    754c:	703d      	strb	r5, [r7, #0]
    754e:	e7f9      	b.n	7544 <prvNotifyQueueSetContainer+0x48>
    7550:	0000748d 	.word	0x0000748d
    7554:	000072e5 	.word	0x000072e5

00007558 <prvCopyDataFromQueue>:
{
    7558:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    755a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    755c:	b510      	push	{r4, lr}
    755e:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    7560:	b152      	cbz	r2, 7578 <prvCopyDataFromQueue+0x20>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    7562:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    7564:	689c      	ldr	r4, [r3, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    7566:	1889      	adds	r1, r1, r2
    7568:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    756a:	42a1      	cmp	r1, r4
    756c:	d301      	bcc.n	7572 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    756e:	6819      	ldr	r1, [r3, #0]
    7570:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    7572:	68d9      	ldr	r1, [r3, #12]
    7574:	4b01      	ldr	r3, [pc, #4]	; (757c <prvCopyDataFromQueue+0x24>)
    7576:	4798      	blx	r3
}
    7578:	bd10      	pop	{r4, pc}
    757a:	46c0      	nop			; (mov r8, r8)
    757c:	000081e1 	.word	0x000081e1

00007580 <prvUnlockQueue>:
{
    7580:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7582:	0004      	movs	r4, r0
		int8_t cTxLock = pxQueue->cTxLock;
    7584:	0026      	movs	r6, r4
	taskENTER_CRITICAL();
    7586:	4f1a      	ldr	r7, [pc, #104]	; (75f0 <prvUnlockQueue+0x70>)
		int8_t cTxLock = pxQueue->cTxLock;
    7588:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
    758a:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
    758c:	7835      	ldrb	r5, [r6, #0]
    758e:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    7590:	2d00      	cmp	r5, #0
    7592:	dc0e      	bgt.n	75b2 <prvUnlockQueue+0x32>
		pxQueue->cTxLock = queueUNLOCKED;
    7594:	23ff      	movs	r3, #255	; 0xff
    7596:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();
    7598:	4e16      	ldr	r6, [pc, #88]	; (75f4 <prvUnlockQueue+0x74>)
    759a:	47b0      	blx	r6
	taskENTER_CRITICAL();
    759c:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
    759e:	0027      	movs	r7, r4
    75a0:	3744      	adds	r7, #68	; 0x44
    75a2:	783d      	ldrb	r5, [r7, #0]
    75a4:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    75a6:	2d00      	cmp	r5, #0
    75a8:	dc16      	bgt.n	75d8 <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
    75aa:	23ff      	movs	r3, #255	; 0xff
    75ac:	703b      	strb	r3, [r7, #0]
	taskEXIT_CRITICAL();
    75ae:	47b0      	blx	r6
}
    75b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if( pxQueue->pxQueueSetContainer != NULL )
    75b2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    75b4:	b143      	cbz	r3, 75c8 <prvUnlockQueue+0x48>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
    75b6:	2100      	movs	r1, #0
    75b8:	0020      	movs	r0, r4
    75ba:	4b0f      	ldr	r3, [pc, #60]	; (75f8 <prvUnlockQueue+0x78>)
    75bc:	4798      	blx	r3
    75be:	b108      	cbz	r0, 75c4 <prvUnlockQueue+0x44>
						vTaskMissedYield();
    75c0:	4b0e      	ldr	r3, [pc, #56]	; (75fc <prvUnlockQueue+0x7c>)
    75c2:	4798      	blx	r3
    75c4:	3d01      	subs	r5, #1
    75c6:	e7e2      	b.n	758e <prvUnlockQueue+0xe>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    75c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    75ca:	2b00      	cmp	r3, #0
    75cc:	d0e2      	beq.n	7594 <prvUnlockQueue+0x14>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    75ce:	0020      	movs	r0, r4
    75d0:	4b0b      	ldr	r3, [pc, #44]	; (7600 <prvUnlockQueue+0x80>)
    75d2:	3024      	adds	r0, #36	; 0x24
    75d4:	4798      	blx	r3
    75d6:	e7f2      	b.n	75be <prvUnlockQueue+0x3e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    75d8:	6923      	ldr	r3, [r4, #16]
    75da:	2b00      	cmp	r3, #0
    75dc:	d0e5      	beq.n	75aa <prvUnlockQueue+0x2a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    75de:	0020      	movs	r0, r4
    75e0:	4b07      	ldr	r3, [pc, #28]	; (7600 <prvUnlockQueue+0x80>)
    75e2:	3010      	adds	r0, #16
    75e4:	4798      	blx	r3
    75e6:	b108      	cbz	r0, 75ec <prvUnlockQueue+0x6c>
					vTaskMissedYield();
    75e8:	4b04      	ldr	r3, [pc, #16]	; (75fc <prvUnlockQueue+0x7c>)
    75ea:	4798      	blx	r3
    75ec:	3d01      	subs	r5, #1
    75ee:	e7d9      	b.n	75a4 <prvUnlockQueue+0x24>
    75f0:	00007f8d 	.word	0x00007f8d
    75f4:	00007fa5 	.word	0x00007fa5
    75f8:	000074fd 	.word	0x000074fd
    75fc:	000073dd 	.word	0x000073dd
    7600:	000072e5 	.word	0x000072e5

00007604 <xQueueGenericReset>:
{
    7604:	b570      	push	{r4, r5, r6, lr}
    7606:	0004      	movs	r4, r0
    7608:	000d      	movs	r5, r1
	configASSERT( pxQueue );
    760a:	b908      	cbnz	r0, 7610 <xQueueGenericReset+0xc>
    760c:	b672      	cpsid	i
    760e:	e7fe      	b.n	760e <xQueueGenericReset+0xa>
	taskENTER_CRITICAL();
    7610:	4b14      	ldr	r3, [pc, #80]	; (7664 <xQueueGenericReset+0x60>)
    7612:	4798      	blx	r3
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    7614:	6c21      	ldr	r1, [r4, #64]	; 0x40
    7616:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    7618:	6822      	ldr	r2, [r4, #0]
    761a:	434b      	muls	r3, r1
    761c:	18d0      	adds	r0, r2, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    761e:	1a5b      	subs	r3, r3, r1
    7620:	18d3      	adds	r3, r2, r3
    7622:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    7624:	0023      	movs	r3, r4
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    7626:	60a0      	str	r0, [r4, #8]
		pxQueue->pcWriteTo = pxQueue->pcHead;
    7628:	6062      	str	r2, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    762a:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
    762c:	22ff      	movs	r2, #255	; 0xff
    762e:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    7630:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
    7632:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
    7634:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
    7636:	b965      	cbnz	r5, 7652 <xQueueGenericReset+0x4e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    7638:	6923      	ldr	r3, [r4, #16]
    763a:	b133      	cbz	r3, 764a <xQueueGenericReset+0x46>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    763c:	0020      	movs	r0, r4
    763e:	4b0a      	ldr	r3, [pc, #40]	; (7668 <xQueueGenericReset+0x64>)
    7640:	3010      	adds	r0, #16
    7642:	4798      	blx	r3
    7644:	b108      	cbz	r0, 764a <xQueueGenericReset+0x46>
					queueYIELD_IF_USING_PREEMPTION();
    7646:	4b09      	ldr	r3, [pc, #36]	; (766c <xQueueGenericReset+0x68>)
    7648:	4798      	blx	r3
	taskEXIT_CRITICAL();
    764a:	4b09      	ldr	r3, [pc, #36]	; (7670 <xQueueGenericReset+0x6c>)
    764c:	4798      	blx	r3
}
    764e:	2001      	movs	r0, #1
    7650:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    7652:	0020      	movs	r0, r4
    7654:	4d07      	ldr	r5, [pc, #28]	; (7674 <xQueueGenericReset+0x70>)
    7656:	3010      	adds	r0, #16
    7658:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    765a:	0020      	movs	r0, r4
    765c:	3024      	adds	r0, #36	; 0x24
    765e:	47a8      	blx	r5
    7660:	e7f3      	b.n	764a <xQueueGenericReset+0x46>
    7662:	46c0      	nop			; (mov r8, r8)
    7664:	00007f8d 	.word	0x00007f8d
    7668:	000072e5 	.word	0x000072e5
    766c:	00007f75 	.word	0x00007f75
    7670:	00007fa5 	.word	0x00007fa5
    7674:	00007a79 	.word	0x00007a79

00007678 <xQueueGenericCreate>:
	{
    7678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    767a:	0006      	movs	r6, r0
    767c:	000d      	movs	r5, r1
    767e:	0017      	movs	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    7680:	b908      	cbnz	r0, 7686 <xQueueGenericCreate+0xe>
    7682:	b672      	cpsid	i
    7684:	e7fe      	b.n	7684 <xQueueGenericCreate+0xc>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7686:	0008      	movs	r0, r1
    7688:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    768a:	4b0c      	ldr	r3, [pc, #48]	; (76bc <xQueueGenericCreate+0x44>)
    768c:	3054      	adds	r0, #84	; 0x54
    768e:	4798      	blx	r3
    7690:	0004      	movs	r4, r0
		if( pxNewQueue != NULL )
    7692:	b160      	cbz	r0, 76ae <xQueueGenericCreate+0x36>
	if( uxItemSize == ( UBaseType_t ) 0 )
    7694:	b96d      	cbnz	r5, 76b2 <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    7696:	6020      	str	r0, [r4, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    7698:	4b09      	ldr	r3, [pc, #36]	; (76c0 <xQueueGenericCreate+0x48>)
	pxNewQueue->uxLength = uxQueueLength;
    769a:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    769c:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    769e:	2101      	movs	r1, #1
    76a0:	0020      	movs	r0, r4
    76a2:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
    76a4:	0023      	movs	r3, r4
    76a6:	3350      	adds	r3, #80	; 0x50
    76a8:	701f      	strb	r7, [r3, #0]
		pxNewQueue->pxQueueSetContainer = NULL;
    76aa:	2300      	movs	r3, #0
    76ac:	64a3      	str	r3, [r4, #72]	; 0x48
	}
    76ae:	0020      	movs	r0, r4
    76b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    76b2:	0003      	movs	r3, r0
    76b4:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    76b6:	6003      	str	r3, [r0, #0]
    76b8:	e7ee      	b.n	7698 <xQueueGenericCreate+0x20>
    76ba:	46c0      	nop			; (mov r8, r8)
    76bc:	00007e21 	.word	0x00007e21
    76c0:	00007605 	.word	0x00007605

000076c4 <xQueueGenericSend>:
{
    76c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    76c6:	b089      	sub	sp, #36	; 0x24
    76c8:	0004      	movs	r4, r0
    76ca:	9102      	str	r1, [sp, #8]
    76cc:	9205      	str	r2, [sp, #20]
    76ce:	9301      	str	r3, [sp, #4]
	configASSERT( pxQueue );
    76d0:	b908      	cbnz	r0, 76d6 <xQueueGenericSend+0x12>
    76d2:	b672      	cpsid	i
    76d4:	e7fe      	b.n	76d4 <xQueueGenericSend+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    76d6:	9b02      	ldr	r3, [sp, #8]
    76d8:	2b00      	cmp	r3, #0
    76da:	d000      	beq.n	76de <xQueueGenericSend+0x1a>
    76dc:	e076      	b.n	77cc <xQueueGenericSend+0x108>
    76de:	6c03      	ldr	r3, [r0, #64]	; 0x40
    76e0:	2b00      	cmp	r3, #0
    76e2:	d100      	bne.n	76e6 <xQueueGenericSend+0x22>
    76e4:	e072      	b.n	77cc <xQueueGenericSend+0x108>
    76e6:	b672      	cpsid	i
    76e8:	e7fe      	b.n	76e8 <xQueueGenericSend+0x24>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    76ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
    76ec:	2b00      	cmp	r3, #0
    76ee:	d05e      	beq.n	77ae <xQueueGenericSend+0xea>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    76f0:	0020      	movs	r0, r4
    76f2:	4b3f      	ldr	r3, [pc, #252]	; (77f0 <xQueueGenericSend+0x12c>)
    76f4:	3024      	adds	r0, #36	; 0x24
    76f6:	4798      	blx	r3
    76f8:	e059      	b.n	77ae <xQueueGenericSend+0xea>
				if( xTicksToWait == ( TickType_t ) 0 )
    76fa:	9d05      	ldr	r5, [sp, #20]
    76fc:	b915      	cbnz	r5, 7704 <xQueueGenericSend+0x40>
					taskEXIT_CRITICAL();
    76fe:	47b8      	blx	r7
			return errQUEUE_FULL;
    7700:	2000      	movs	r0, #0
    7702:	e059      	b.n	77b8 <xQueueGenericSend+0xf4>
				else if( xEntryTimeSet == pdFALSE )
    7704:	b916      	cbnz	r6, 770c <xQueueGenericSend+0x48>
					vTaskInternalSetTimeOutState( &xTimeOut );
    7706:	a806      	add	r0, sp, #24
    7708:	4b3a      	ldr	r3, [pc, #232]	; (77f4 <xQueueGenericSend+0x130>)
    770a:	4798      	blx	r3
		taskEXIT_CRITICAL();
    770c:	47b8      	blx	r7
		vTaskSuspendAll();
    770e:	4b3a      	ldr	r3, [pc, #232]	; (77f8 <xQueueGenericSend+0x134>)
    7710:	4798      	blx	r3
		prvLockQueue( pxQueue );
    7712:	9b03      	ldr	r3, [sp, #12]
    7714:	4798      	blx	r3
    7716:	0022      	movs	r2, r4
    7718:	3244      	adds	r2, #68	; 0x44
    771a:	7813      	ldrb	r3, [r2, #0]
    771c:	b25b      	sxtb	r3, r3
    771e:	3301      	adds	r3, #1
    7720:	d101      	bne.n	7726 <xQueueGenericSend+0x62>
    7722:	2300      	movs	r3, #0
    7724:	7013      	strb	r3, [r2, #0]
    7726:	0022      	movs	r2, r4
    7728:	3245      	adds	r2, #69	; 0x45
    772a:	7813      	ldrb	r3, [r2, #0]
    772c:	b25b      	sxtb	r3, r3
    772e:	3301      	adds	r3, #1
    7730:	d101      	bne.n	7736 <xQueueGenericSend+0x72>
    7732:	2300      	movs	r3, #0
    7734:	7013      	strb	r3, [r2, #0]
    7736:	47b8      	blx	r7
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    7738:	a905      	add	r1, sp, #20
    773a:	a806      	add	r0, sp, #24
    773c:	4b2f      	ldr	r3, [pc, #188]	; (77fc <xQueueGenericSend+0x138>)
    773e:	4798      	blx	r3
    7740:	4e2f      	ldr	r6, [pc, #188]	; (7800 <xQueueGenericSend+0x13c>)
    7742:	4d30      	ldr	r5, [pc, #192]	; (7804 <xQueueGenericSend+0x140>)
    7744:	2800      	cmp	r0, #0
    7746:	d13d      	bne.n	77c4 <xQueueGenericSend+0x100>
	taskENTER_CRITICAL();
    7748:	9b03      	ldr	r3, [sp, #12]
    774a:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    774c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    774e:	9303      	str	r3, [sp, #12]
    7750:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    7752:	9304      	str	r3, [sp, #16]
	taskEXIT_CRITICAL();
    7754:	47b8      	blx	r7
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    7756:	9b03      	ldr	r3, [sp, #12]
    7758:	9a04      	ldr	r2, [sp, #16]
    775a:	4293      	cmp	r3, r2
    775c:	d12e      	bne.n	77bc <xQueueGenericSend+0xf8>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    775e:	0020      	movs	r0, r4
    7760:	9905      	ldr	r1, [sp, #20]
    7762:	3010      	adds	r0, #16
    7764:	4b28      	ldr	r3, [pc, #160]	; (7808 <xQueueGenericSend+0x144>)
    7766:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    7768:	0020      	movs	r0, r4
    776a:	47b0      	blx	r6
				if( xTaskResumeAll() == pdFALSE )
    776c:	47a8      	blx	r5
    776e:	b908      	cbnz	r0, 7774 <xQueueGenericSend+0xb0>
					portYIELD_WITHIN_API();
    7770:	4b26      	ldr	r3, [pc, #152]	; (780c <xQueueGenericSend+0x148>)
    7772:	4798      	blx	r3
    7774:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    7776:	4d26      	ldr	r5, [pc, #152]	; (7810 <xQueueGenericSend+0x14c>)
    7778:	47a8      	blx	r5
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    777a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    777c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    777e:	9503      	str	r5, [sp, #12]
    7780:	4f24      	ldr	r7, [pc, #144]	; (7814 <xQueueGenericSend+0x150>)
    7782:	4293      	cmp	r3, r2
    7784:	d302      	bcc.n	778c <xQueueGenericSend+0xc8>
    7786:	9b01      	ldr	r3, [sp, #4]
    7788:	2b02      	cmp	r3, #2
    778a:	d1b6      	bne.n	76fa <xQueueGenericSend+0x36>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    778c:	4b22      	ldr	r3, [pc, #136]	; (7818 <xQueueGenericSend+0x154>)
    778e:	9a01      	ldr	r2, [sp, #4]
    7790:	9902      	ldr	r1, [sp, #8]
    7792:	0020      	movs	r0, r4
				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    7794:	6ba5      	ldr	r5, [r4, #56]	; 0x38
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    7796:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
    7798:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    779a:	2b00      	cmp	r3, #0
    779c:	d0a5      	beq.n	76ea <xQueueGenericSend+0x26>
						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    779e:	9b01      	ldr	r3, [sp, #4]
    77a0:	2b02      	cmp	r3, #2
    77a2:	d100      	bne.n	77a6 <xQueueGenericSend+0xe2>
    77a4:	b935      	cbnz	r5, 77b4 <xQueueGenericSend+0xf0>
						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
    77a6:	9901      	ldr	r1, [sp, #4]
    77a8:	0020      	movs	r0, r4
    77aa:	4b1c      	ldr	r3, [pc, #112]	; (781c <xQueueGenericSend+0x158>)
    77ac:	4798      	blx	r3
    77ae:	b108      	cbz	r0, 77b4 <xQueueGenericSend+0xf0>
							queueYIELD_IF_USING_PREEMPTION();
    77b0:	4b16      	ldr	r3, [pc, #88]	; (780c <xQueueGenericSend+0x148>)
    77b2:	4798      	blx	r3
				taskEXIT_CRITICAL();
    77b4:	47b8      	blx	r7
				return pdPASS;
    77b6:	2001      	movs	r0, #1
}
    77b8:	b009      	add	sp, #36	; 0x24
    77ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
    77bc:	0020      	movs	r0, r4
    77be:	47b0      	blx	r6
				( void ) xTaskResumeAll();
    77c0:	47a8      	blx	r5
    77c2:	e7d7      	b.n	7774 <xQueueGenericSend+0xb0>
			prvUnlockQueue( pxQueue );
    77c4:	0020      	movs	r0, r4
    77c6:	47b0      	blx	r6
			( void ) xTaskResumeAll();
    77c8:	47a8      	blx	r5
    77ca:	e799      	b.n	7700 <xQueueGenericSend+0x3c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    77cc:	9b01      	ldr	r3, [sp, #4]
    77ce:	2b02      	cmp	r3, #2
    77d0:	d102      	bne.n	77d8 <xQueueGenericSend+0x114>
    77d2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    77d4:	2b01      	cmp	r3, #1
    77d6:	d109      	bne.n	77ec <xQueueGenericSend+0x128>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    77d8:	4b11      	ldr	r3, [pc, #68]	; (7820 <xQueueGenericSend+0x15c>)
    77da:	4798      	blx	r3
    77dc:	2600      	movs	r6, #0
    77de:	2800      	cmp	r0, #0
    77e0:	d1c9      	bne.n	7776 <xQueueGenericSend+0xb2>
    77e2:	9e05      	ldr	r6, [sp, #20]
    77e4:	2e00      	cmp	r6, #0
    77e6:	d0c6      	beq.n	7776 <xQueueGenericSend+0xb2>
    77e8:	b672      	cpsid	i
    77ea:	e7fe      	b.n	77ea <xQueueGenericSend+0x126>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    77ec:	b672      	cpsid	i
    77ee:	e7fe      	b.n	77ee <xQueueGenericSend+0x12a>
    77f0:	000072e5 	.word	0x000072e5
    77f4:	00007359 	.word	0x00007359
    77f8:	00006fb9 	.word	0x00006fb9
    77fc:	00007371 	.word	0x00007371
    7800:	00007581 	.word	0x00007581
    7804:	000070bd 	.word	0x000070bd
    7808:	00007285 	.word	0x00007285
    780c:	00007f75 	.word	0x00007f75
    7810:	00007f8d 	.word	0x00007f8d
    7814:	00007fa5 	.word	0x00007fa5
    7818:	0000748d 	.word	0x0000748d
    781c:	000074fd 	.word	0x000074fd
    7820:	000073e9 	.word	0x000073e9

00007824 <xQueueGenericSendFromISR>:
{
    7824:	b5f0      	push	{r4, r5, r6, r7, lr}
    7826:	b085      	sub	sp, #20
    7828:	0004      	movs	r4, r0
    782a:	9101      	str	r1, [sp, #4]
    782c:	0017      	movs	r7, r2
    782e:	001e      	movs	r6, r3
	configASSERT( pxQueue );
    7830:	b908      	cbnz	r0, 7836 <xQueueGenericSendFromISR+0x12>
    7832:	b672      	cpsid	i
    7834:	e7fe      	b.n	7834 <xQueueGenericSendFromISR+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    7836:	9b01      	ldr	r3, [sp, #4]
    7838:	b9cb      	cbnz	r3, 786e <xQueueGenericSendFromISR+0x4a>
    783a:	6c03      	ldr	r3, [r0, #64]	; 0x40
    783c:	b1bb      	cbz	r3, 786e <xQueueGenericSendFromISR+0x4a>
    783e:	b672      	cpsid	i
    7840:	e7fe      	b.n	7840 <xQueueGenericSendFromISR+0x1c>
							if( pxHigherPriorityTaskWoken != NULL )
    7842:	2f00      	cmp	r7, #0
    7844:	d037      	beq.n	78b6 <xQueueGenericSendFromISR+0x92>
								*pxHigherPriorityTaskWoken = pdTRUE;
    7846:	2501      	movs	r5, #1
    7848:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    784a:	9803      	ldr	r0, [sp, #12]
    784c:	4b1c      	ldr	r3, [pc, #112]	; (78c0 <xQueueGenericSendFromISR+0x9c>)
    784e:	4798      	blx	r3
}
    7850:	0028      	movs	r0, r5
    7852:	b005      	add	sp, #20
    7854:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    7856:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7858:	b36b      	cbz	r3, 78b6 <xQueueGenericSendFromISR+0x92>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    785a:	0020      	movs	r0, r4
    785c:	4b19      	ldr	r3, [pc, #100]	; (78c4 <xQueueGenericSendFromISR+0xa0>)
    785e:	3024      	adds	r0, #36	; 0x24
    7860:	4798      	blx	r3
    7862:	e026      	b.n	78b2 <xQueueGenericSendFromISR+0x8e>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    7864:	3501      	adds	r5, #1
    7866:	9b02      	ldr	r3, [sp, #8]
    7868:	b26d      	sxtb	r5, r5
    786a:	701d      	strb	r5, [r3, #0]
    786c:	e023      	b.n	78b6 <xQueueGenericSendFromISR+0x92>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    786e:	2e02      	cmp	r6, #2
    7870:	d102      	bne.n	7878 <xQueueGenericSendFromISR+0x54>
    7872:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    7874:	2b01      	cmp	r3, #1
    7876:	d120      	bne.n	78ba <xQueueGenericSendFromISR+0x96>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7878:	4b13      	ldr	r3, [pc, #76]	; (78c8 <xQueueGenericSendFromISR+0xa4>)
    787a:	4798      	blx	r3
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    787c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    787e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7880:	9003      	str	r0, [sp, #12]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    7882:	4293      	cmp	r3, r2
    7884:	d302      	bcc.n	788c <xQueueGenericSendFromISR+0x68>
			xReturn = errQUEUE_FULL;
    7886:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    7888:	2e02      	cmp	r6, #2
    788a:	d1de      	bne.n	784a <xQueueGenericSendFromISR+0x26>
			const int8_t cTxLock = pxQueue->cTxLock;
    788c:	0023      	movs	r3, r4
    788e:	3345      	adds	r3, #69	; 0x45
    7890:	9302      	str	r3, [sp, #8]
    7892:	781d      	ldrb	r5, [r3, #0]
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    7894:	0032      	movs	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
    7896:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    7898:	4b0c      	ldr	r3, [pc, #48]	; (78cc <xQueueGenericSendFromISR+0xa8>)
    789a:	9901      	ldr	r1, [sp, #4]
    789c:	0020      	movs	r0, r4
    789e:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
    78a0:	1c6b      	adds	r3, r5, #1
    78a2:	d1df      	bne.n	7864 <xQueueGenericSendFromISR+0x40>
					if( pxQueue->pxQueueSetContainer != NULL )
    78a4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    78a6:	2b00      	cmp	r3, #0
    78a8:	d0d5      	beq.n	7856 <xQueueGenericSendFromISR+0x32>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
    78aa:	0031      	movs	r1, r6
    78ac:	0020      	movs	r0, r4
    78ae:	4b08      	ldr	r3, [pc, #32]	; (78d0 <xQueueGenericSendFromISR+0xac>)
    78b0:	4798      	blx	r3
    78b2:	2800      	cmp	r0, #0
    78b4:	d1c5      	bne.n	7842 <xQueueGenericSendFromISR+0x1e>
			xReturn = pdPASS;
    78b6:	2501      	movs	r5, #1
    78b8:	e7c7      	b.n	784a <xQueueGenericSendFromISR+0x26>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    78ba:	b672      	cpsid	i
    78bc:	e7fe      	b.n	78bc <xQueueGenericSendFromISR+0x98>
    78be:	46c0      	nop			; (mov r8, r8)
    78c0:	00007fc5 	.word	0x00007fc5
    78c4:	000072e5 	.word	0x000072e5
    78c8:	00007fbd 	.word	0x00007fbd
    78cc:	0000748d 	.word	0x0000748d
    78d0:	000074fd 	.word	0x000074fd

000078d4 <xQueueReceive>:
{
    78d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    78d6:	b087      	sub	sp, #28
    78d8:	0004      	movs	r4, r0
    78da:	9101      	str	r1, [sp, #4]
    78dc:	9203      	str	r2, [sp, #12]
	configASSERT( ( pxQueue ) );
    78de:	b908      	cbnz	r0, 78e4 <xQueueReceive+0x10>
    78e0:	b672      	cpsid	i
    78e2:	e7fe      	b.n	78e2 <xQueueReceive+0xe>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    78e4:	9b01      	ldr	r3, [sp, #4]
    78e6:	2b00      	cmp	r3, #0
    78e8:	d163      	bne.n	79b2 <xQueueReceive+0xde>
    78ea:	6c03      	ldr	r3, [r0, #64]	; 0x40
    78ec:	2b00      	cmp	r3, #0
    78ee:	d060      	beq.n	79b2 <xQueueReceive+0xde>
    78f0:	b672      	cpsid	i
    78f2:	e7fe      	b.n	78f2 <xQueueReceive+0x1e>
				if( xTicksToWait == ( TickType_t ) 0 )
    78f4:	9d03      	ldr	r5, [sp, #12]
    78f6:	b915      	cbnz	r5, 78fe <xQueueReceive+0x2a>
					taskEXIT_CRITICAL();
    78f8:	47b8      	blx	r7
				return errQUEUE_EMPTY;
    78fa:	2000      	movs	r0, #0
    78fc:	e04b      	b.n	7996 <xQueueReceive+0xc2>
				else if( xEntryTimeSet == pdFALSE )
    78fe:	b916      	cbnz	r6, 7906 <xQueueReceive+0x32>
					vTaskInternalSetTimeOutState( &xTimeOut );
    7900:	a804      	add	r0, sp, #16
    7902:	4b31      	ldr	r3, [pc, #196]	; (79c8 <xQueueReceive+0xf4>)
    7904:	4798      	blx	r3
		taskEXIT_CRITICAL();
    7906:	47b8      	blx	r7
		vTaskSuspendAll();
    7908:	4b30      	ldr	r3, [pc, #192]	; (79cc <xQueueReceive+0xf8>)
    790a:	4798      	blx	r3
		prvLockQueue( pxQueue );
    790c:	9b02      	ldr	r3, [sp, #8]
    790e:	4798      	blx	r3
    7910:	0022      	movs	r2, r4
    7912:	3244      	adds	r2, #68	; 0x44
    7914:	7813      	ldrb	r3, [r2, #0]
    7916:	b25b      	sxtb	r3, r3
    7918:	3301      	adds	r3, #1
    791a:	d101      	bne.n	7920 <xQueueReceive+0x4c>
    791c:	2300      	movs	r3, #0
    791e:	7013      	strb	r3, [r2, #0]
    7920:	0022      	movs	r2, r4
    7922:	3245      	adds	r2, #69	; 0x45
    7924:	7813      	ldrb	r3, [r2, #0]
    7926:	b25b      	sxtb	r3, r3
    7928:	3301      	adds	r3, #1
    792a:	d101      	bne.n	7930 <xQueueReceive+0x5c>
    792c:	2300      	movs	r3, #0
    792e:	7013      	strb	r3, [r2, #0]
    7930:	47b8      	blx	r7
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    7932:	a903      	add	r1, sp, #12
    7934:	a804      	add	r0, sp, #16
    7936:	4b26      	ldr	r3, [pc, #152]	; (79d0 <xQueueReceive+0xfc>)
    7938:	4798      	blx	r3
    793a:	4f26      	ldr	r7, [pc, #152]	; (79d4 <xQueueReceive+0x100>)
    793c:	4d26      	ldr	r5, [pc, #152]	; (79d8 <xQueueReceive+0x104>)
    793e:	4e27      	ldr	r6, [pc, #156]	; (79dc <xQueueReceive+0x108>)
    7940:	2800      	cmp	r0, #0
    7942:	d12e      	bne.n	79a2 <xQueueReceive+0xce>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    7944:	0020      	movs	r0, r4
    7946:	47b8      	blx	r7
    7948:	b338      	cbz	r0, 799a <xQueueReceive+0xc6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    794a:	0020      	movs	r0, r4
    794c:	9903      	ldr	r1, [sp, #12]
    794e:	3024      	adds	r0, #36	; 0x24
    7950:	4b23      	ldr	r3, [pc, #140]	; (79e0 <xQueueReceive+0x10c>)
    7952:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    7954:	0020      	movs	r0, r4
    7956:	47a8      	blx	r5
				if( xTaskResumeAll() == pdFALSE )
    7958:	47b0      	blx	r6
    795a:	b908      	cbnz	r0, 7960 <xQueueReceive+0x8c>
					portYIELD_WITHIN_API();
    795c:	4b21      	ldr	r3, [pc, #132]	; (79e4 <xQueueReceive+0x110>)
    795e:	4798      	blx	r3
    7960:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    7962:	4d21      	ldr	r5, [pc, #132]	; (79e8 <xQueueReceive+0x114>)
    7964:	47a8      	blx	r5
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    7966:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    7968:	9502      	str	r5, [sp, #8]
    796a:	9300      	str	r3, [sp, #0]
    796c:	4f1f      	ldr	r7, [pc, #124]	; (79ec <xQueueReceive+0x118>)
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    796e:	2b00      	cmp	r3, #0
    7970:	d0c0      	beq.n	78f4 <xQueueReceive+0x20>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    7972:	4b1f      	ldr	r3, [pc, #124]	; (79f0 <xQueueReceive+0x11c>)
    7974:	9901      	ldr	r1, [sp, #4]
    7976:	0020      	movs	r0, r4
    7978:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    797a:	9b00      	ldr	r3, [sp, #0]
    797c:	3b01      	subs	r3, #1
    797e:	63a3      	str	r3, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    7980:	6923      	ldr	r3, [r4, #16]
    7982:	b133      	cbz	r3, 7992 <xQueueReceive+0xbe>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    7984:	0020      	movs	r0, r4
    7986:	4b1b      	ldr	r3, [pc, #108]	; (79f4 <xQueueReceive+0x120>)
    7988:	3010      	adds	r0, #16
    798a:	4798      	blx	r3
    798c:	b108      	cbz	r0, 7992 <xQueueReceive+0xbe>
						queueYIELD_IF_USING_PREEMPTION();
    798e:	4b15      	ldr	r3, [pc, #84]	; (79e4 <xQueueReceive+0x110>)
    7990:	4798      	blx	r3
				taskEXIT_CRITICAL();
    7992:	47b8      	blx	r7
				return pdPASS;
    7994:	2001      	movs	r0, #1
}
    7996:	b007      	add	sp, #28
    7998:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
    799a:	0020      	movs	r0, r4
    799c:	47a8      	blx	r5
				( void ) xTaskResumeAll();
    799e:	47b0      	blx	r6
    79a0:	e7de      	b.n	7960 <xQueueReceive+0x8c>
			prvUnlockQueue( pxQueue );
    79a2:	0020      	movs	r0, r4
    79a4:	47a8      	blx	r5
			( void ) xTaskResumeAll();
    79a6:	47b0      	blx	r6
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    79a8:	0020      	movs	r0, r4
    79aa:	47b8      	blx	r7
    79ac:	2800      	cmp	r0, #0
    79ae:	d0d7      	beq.n	7960 <xQueueReceive+0x8c>
    79b0:	e7a3      	b.n	78fa <xQueueReceive+0x26>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    79b2:	4b11      	ldr	r3, [pc, #68]	; (79f8 <xQueueReceive+0x124>)
    79b4:	4798      	blx	r3
    79b6:	2600      	movs	r6, #0
    79b8:	2800      	cmp	r0, #0
    79ba:	d1d2      	bne.n	7962 <xQueueReceive+0x8e>
    79bc:	9e03      	ldr	r6, [sp, #12]
    79be:	2e00      	cmp	r6, #0
    79c0:	d0cf      	beq.n	7962 <xQueueReceive+0x8e>
    79c2:	b672      	cpsid	i
    79c4:	e7fe      	b.n	79c4 <xQueueReceive+0xf0>
    79c6:	46c0      	nop			; (mov r8, r8)
    79c8:	00007359 	.word	0x00007359
    79cc:	00006fb9 	.word	0x00006fb9
    79d0:	00007371 	.word	0x00007371
    79d4:	00007471 	.word	0x00007471
    79d8:	00007581 	.word	0x00007581
    79dc:	000070bd 	.word	0x000070bd
    79e0:	00007285 	.word	0x00007285
    79e4:	00007f75 	.word	0x00007f75
    79e8:	00007f8d 	.word	0x00007f8d
    79ec:	00007fa5 	.word	0x00007fa5
    79f0:	00007559 	.word	0x00007559
    79f4:	000072e5 	.word	0x000072e5
    79f8:	000073e9 	.word	0x000073e9

000079fc <vQueueAddToRegistry>:
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    79fc:	2300      	movs	r3, #0
	{
    79fe:	b530      	push	{r4, r5, lr}
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    7a00:	4a06      	ldr	r2, [pc, #24]	; (7a1c <vQueueAddToRegistry+0x20>)
    7a02:	00dc      	lsls	r4, r3, #3
    7a04:	18a2      	adds	r2, r4, r2
    7a06:	6815      	ldr	r5, [r2, #0]
    7a08:	b91d      	cbnz	r5, 7a12 <vQueueAddToRegistry+0x16>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    7a0a:	4b04      	ldr	r3, [pc, #16]	; (7a1c <vQueueAddToRegistry+0x20>)
				xQueueRegistry[ ux ].xHandle = xQueue;
    7a0c:	6050      	str	r0, [r2, #4]
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    7a0e:	50e1      	str	r1, [r4, r3]
	}
    7a10:	bd30      	pop	{r4, r5, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    7a12:	3301      	adds	r3, #1
    7a14:	2b08      	cmp	r3, #8
    7a16:	d1f3      	bne.n	7a00 <vQueueAddToRegistry+0x4>
    7a18:	e7fa      	b.n	7a10 <vQueueAddToRegistry+0x14>
    7a1a:	46c0      	nop			; (mov r8, r8)
    7a1c:	20002c6c 	.word	0x20002c6c

00007a20 <vQueueWaitForMessageRestricted>:
	{
    7a20:	b570      	push	{r4, r5, r6, lr}
    7a22:	0004      	movs	r4, r0
		prvLockQueue( pxQueue );
    7a24:	4b10      	ldr	r3, [pc, #64]	; (7a68 <vQueueWaitForMessageRestricted+0x48>)
	{
    7a26:	0016      	movs	r6, r2
    7a28:	000d      	movs	r5, r1
		prvLockQueue( pxQueue );
    7a2a:	4798      	blx	r3
    7a2c:	0022      	movs	r2, r4
    7a2e:	3244      	adds	r2, #68	; 0x44
    7a30:	7813      	ldrb	r3, [r2, #0]
    7a32:	b25b      	sxtb	r3, r3
    7a34:	3301      	adds	r3, #1
    7a36:	d101      	bne.n	7a3c <vQueueWaitForMessageRestricted+0x1c>
    7a38:	2300      	movs	r3, #0
    7a3a:	7013      	strb	r3, [r2, #0]
    7a3c:	0022      	movs	r2, r4
    7a3e:	3245      	adds	r2, #69	; 0x45
    7a40:	7813      	ldrb	r3, [r2, #0]
    7a42:	b25b      	sxtb	r3, r3
    7a44:	3301      	adds	r3, #1
    7a46:	d101      	bne.n	7a4c <vQueueWaitForMessageRestricted+0x2c>
    7a48:	2300      	movs	r3, #0
    7a4a:	7013      	strb	r3, [r2, #0]
    7a4c:	4b07      	ldr	r3, [pc, #28]	; (7a6c <vQueueWaitForMessageRestricted+0x4c>)
    7a4e:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    7a50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    7a52:	b92b      	cbnz	r3, 7a60 <vQueueWaitForMessageRestricted+0x40>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    7a54:	0020      	movs	r0, r4
    7a56:	0032      	movs	r2, r6
    7a58:	0029      	movs	r1, r5
    7a5a:	3024      	adds	r0, #36	; 0x24
    7a5c:	4b04      	ldr	r3, [pc, #16]	; (7a70 <vQueueWaitForMessageRestricted+0x50>)
    7a5e:	4798      	blx	r3
		prvUnlockQueue( pxQueue );
    7a60:	0020      	movs	r0, r4
    7a62:	4b04      	ldr	r3, [pc, #16]	; (7a74 <vQueueWaitForMessageRestricted+0x54>)
    7a64:	4798      	blx	r3
	}
    7a66:	bd70      	pop	{r4, r5, r6, pc}
    7a68:	00007f8d 	.word	0x00007f8d
    7a6c:	00007fa5 	.word	0x00007fa5
    7a70:	000072b1 	.word	0x000072b1
    7a74:	00007581 	.word	0x00007581

00007a78 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    7a78:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    7a7a:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    7a7c:	3308      	adds	r3, #8
    7a7e:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    7a80:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    7a82:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    7a84:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    7a86:	4252      	negs	r2, r2
    7a88:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    7a8a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    7a8c:	4770      	bx	lr

00007a8e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    7a8e:	2300      	movs	r3, #0
    7a90:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    7a92:	4770      	bx	lr

00007a94 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
    7a94:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    7a96:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
    7a98:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    7a9a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    7a9c:	689a      	ldr	r2, [r3, #8]
    7a9e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
    7aa0:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
    7aa2:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxContainer = pxList;
    7aa4:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    7aa6:	3301      	adds	r3, #1
    7aa8:	6003      	str	r3, [r0, #0]
}
    7aaa:	4770      	bx	lr

00007aac <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    7aac:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    7aae:	680a      	ldr	r2, [r1, #0]
{
    7ab0:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    7ab2:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
    7ab4:	1c54      	adds	r4, r2, #1
    7ab6:	d10b      	bne.n	7ad0 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
    7ab8:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    7aba:	685a      	ldr	r2, [r3, #4]
    7abc:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    7abe:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
    7ac0:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
    7ac2:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
    7ac4:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxContainer = pxList;
    7ac6:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    7ac8:	3301      	adds	r3, #1
    7aca:	6003      	str	r3, [r0, #0]
}
    7acc:	bd30      	pop	{r4, r5, pc}
    7ace:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    7ad0:	685c      	ldr	r4, [r3, #4]
    7ad2:	6825      	ldr	r5, [r4, #0]
    7ad4:	42aa      	cmp	r2, r5
    7ad6:	d2fa      	bcs.n	7ace <vListInsert+0x22>
    7ad8:	e7ef      	b.n	7aba <vListInsert+0xe>

00007ada <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    7ada:	6841      	ldr	r1, [r0, #4]
    7adc:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = pxItemToRemove->pxContainer;
    7ade:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    7ae0:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    7ae2:	6882      	ldr	r2, [r0, #8]
    7ae4:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    7ae6:	6859      	ldr	r1, [r3, #4]
    7ae8:	4288      	cmp	r0, r1
    7aea:	d100      	bne.n	7aee <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    7aec:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    7aee:	2200      	movs	r2, #0
    7af0:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
    7af2:	681a      	ldr	r2, [r3, #0]
    7af4:	3a01      	subs	r2, #1
    7af6:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    7af8:	6818      	ldr	r0, [r3, #0]
}
    7afa:	4770      	bx	lr

00007afc <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    7afc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
    7afe:	4c0e      	ldr	r4, [pc, #56]	; (7b38 <prvCheckForValidListAndQueue+0x3c>)
	taskENTER_CRITICAL();
    7b00:	4b0e      	ldr	r3, [pc, #56]	; (7b3c <prvCheckForValidListAndQueue+0x40>)
    7b02:	4798      	blx	r3
		if( xTimerQueue == NULL )
    7b04:	6823      	ldr	r3, [r4, #0]
    7b06:	9301      	str	r3, [sp, #4]
    7b08:	b99b      	cbnz	r3, 7b32 <prvCheckForValidListAndQueue+0x36>
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
    7b0a:	0025      	movs	r5, r4
			vListInitialise( &xActiveTimerList1 );
    7b0c:	1d26      	adds	r6, r4, #4
    7b0e:	0030      	movs	r0, r6
    7b10:	4f0b      	ldr	r7, [pc, #44]	; (7b40 <prvCheckForValidListAndQueue+0x44>)
			vListInitialise( &xActiveTimerList2 );
    7b12:	3518      	adds	r5, #24
			vListInitialise( &xActiveTimerList1 );
    7b14:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    7b16:	0028      	movs	r0, r5
    7b18:	47b8      	blx	r7

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    7b1a:	9a01      	ldr	r2, [sp, #4]
    7b1c:	210c      	movs	r1, #12
    7b1e:	2005      	movs	r0, #5
    7b20:	4b08      	ldr	r3, [pc, #32]	; (7b44 <prvCheckForValidListAndQueue+0x48>)
			pxCurrentTimerList = &xActiveTimerList1;
    7b22:	62e6      	str	r6, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
    7b24:	6325      	str	r5, [r4, #48]	; 0x30
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    7b26:	4798      	blx	r3
    7b28:	6020      	str	r0, [r4, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
    7b2a:	b110      	cbz	r0, 7b32 <prvCheckForValidListAndQueue+0x36>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    7b2c:	4906      	ldr	r1, [pc, #24]	; (7b48 <prvCheckForValidListAndQueue+0x4c>)
    7b2e:	4b07      	ldr	r3, [pc, #28]	; (7b4c <prvCheckForValidListAndQueue+0x50>)
    7b30:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    7b32:	4b07      	ldr	r3, [pc, #28]	; (7b50 <prvCheckForValidListAndQueue+0x54>)
    7b34:	4798      	blx	r3
}
    7b36:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    7b38:	2000012c 	.word	0x2000012c
    7b3c:	00007f8d 	.word	0x00007f8d
    7b40:	00007a79 	.word	0x00007a79
    7b44:	00007679 	.word	0x00007679
    7b48:	00008207 	.word	0x00008207
    7b4c:	000079fd 	.word	0x000079fd
    7b50:	00007fa5 	.word	0x00007fa5

00007b54 <prvInsertTimerInActiveList>:
{
    7b54:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    7b56:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    7b58:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
    7b5a:	4291      	cmp	r1, r2
    7b5c:	d80c      	bhi.n	7b78 <prvInsertTimerInActiveList+0x24>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7b5e:	1ad2      	subs	r2, r2, r3
    7b60:	6983      	ldr	r3, [r0, #24]
			xProcessTimerNow = pdTRUE;
    7b62:	2401      	movs	r4, #1
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7b64:	429a      	cmp	r2, r3
    7b66:	d205      	bcs.n	7b74 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    7b68:	4b08      	ldr	r3, [pc, #32]	; (7b8c <prvInsertTimerInActiveList+0x38>)
    7b6a:	1d01      	adds	r1, r0, #4
    7b6c:	6b18      	ldr	r0, [r3, #48]	; 0x30
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    7b6e:	4b08      	ldr	r3, [pc, #32]	; (7b90 <prvInsertTimerInActiveList+0x3c>)
    7b70:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    7b72:	2400      	movs	r4, #0
}
    7b74:	0020      	movs	r0, r4
    7b76:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    7b78:	429a      	cmp	r2, r3
    7b7a:	d202      	bcs.n	7b82 <prvInsertTimerInActiveList+0x2e>
			xProcessTimerNow = pdTRUE;
    7b7c:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    7b7e:	4299      	cmp	r1, r3
    7b80:	d2f8      	bcs.n	7b74 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    7b82:	4b02      	ldr	r3, [pc, #8]	; (7b8c <prvInsertTimerInActiveList+0x38>)
    7b84:	1d01      	adds	r1, r0, #4
    7b86:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    7b88:	e7f1      	b.n	7b6e <prvInsertTimerInActiveList+0x1a>
    7b8a:	46c0      	nop			; (mov r8, r8)
    7b8c:	2000012c 	.word	0x2000012c
    7b90:	00007aad 	.word	0x00007aad

00007b94 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    7b94:	4b0a      	ldr	r3, [pc, #40]	; (7bc0 <xTimerCreateTimerTask+0x2c>)
{
    7b96:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    7b98:	4798      	blx	r3
	if( xTimerQueue != NULL )
    7b9a:	4b0a      	ldr	r3, [pc, #40]	; (7bc4 <xTimerCreateTimerTask+0x30>)
    7b9c:	681a      	ldr	r2, [r3, #0]
    7b9e:	b90a      	cbnz	r2, 7ba4 <xTimerCreateTimerTask+0x10>
	configASSERT( xReturn );
    7ba0:	b672      	cpsid	i
    7ba2:	e7fe      	b.n	7ba2 <xTimerCreateTimerTask+0xe>
			xReturn = xTaskCreate(	prvTimerTask,
    7ba4:	3334      	adds	r3, #52	; 0x34
    7ba6:	9301      	str	r3, [sp, #4]
    7ba8:	2302      	movs	r3, #2
    7baa:	2250      	movs	r2, #80	; 0x50
    7bac:	9300      	str	r3, [sp, #0]
    7bae:	4906      	ldr	r1, [pc, #24]	; (7bc8 <xTimerCreateTimerTask+0x34>)
    7bb0:	2300      	movs	r3, #0
    7bb2:	4806      	ldr	r0, [pc, #24]	; (7bcc <xTimerCreateTimerTask+0x38>)
    7bb4:	4c06      	ldr	r4, [pc, #24]	; (7bd0 <xTimerCreateTimerTask+0x3c>)
    7bb6:	47a0      	blx	r4
	configASSERT( xReturn );
    7bb8:	2800      	cmp	r0, #0
    7bba:	d0f1      	beq.n	7ba0 <xTimerCreateTimerTask+0xc>
}
    7bbc:	bd16      	pop	{r1, r2, r4, pc}
    7bbe:	46c0      	nop			; (mov r8, r8)
    7bc0:	00007afd 	.word	0x00007afd
    7bc4:	2000012c 	.word	0x2000012c
    7bc8:	0000820c 	.word	0x0000820c
    7bcc:	00007c95 	.word	0x00007c95
    7bd0:	00006dc9 	.word	0x00006dc9

00007bd4 <xTimerGenericCommand>:
{
    7bd4:	b5f0      	push	{r4, r5, r6, r7, lr}
    7bd6:	0017      	movs	r7, r2
    7bd8:	b085      	sub	sp, #20
    7bda:	0006      	movs	r6, r0
    7bdc:	001a      	movs	r2, r3
	configASSERT( xTimer );
    7bde:	b908      	cbnz	r0, 7be4 <xTimerGenericCommand+0x10>
    7be0:	b672      	cpsid	i
    7be2:	e7fe      	b.n	7be2 <xTimerGenericCommand+0xe>
	if( xTimerQueue != NULL )
    7be4:	4d0d      	ldr	r5, [pc, #52]	; (7c1c <xTimerGenericCommand+0x48>)
    7be6:	682c      	ldr	r4, [r5, #0]
BaseType_t xReturn = pdFAIL;
    7be8:	0020      	movs	r0, r4
	if( xTimerQueue != NULL )
    7bea:	b17c      	cbz	r4, 7c0c <xTimerGenericCommand+0x38>
		xMessage.xMessageID = xCommandID;
    7bec:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    7bee:	9702      	str	r7, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    7bf0:	9603      	str	r6, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    7bf2:	2905      	cmp	r1, #5
    7bf4:	dc0c      	bgt.n	7c10 <xTimerGenericCommand+0x3c>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    7bf6:	4b0a      	ldr	r3, [pc, #40]	; (7c20 <xTimerGenericCommand+0x4c>)
    7bf8:	4798      	blx	r3
    7bfa:	4c0a      	ldr	r4, [pc, #40]	; (7c24 <xTimerGenericCommand+0x50>)
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    7bfc:	2300      	movs	r3, #0
    7bfe:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    7c00:	2802      	cmp	r0, #2
    7c02:	d000      	beq.n	7c06 <xTimerGenericCommand+0x32>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    7c04:	001a      	movs	r2, r3
    7c06:	6828      	ldr	r0, [r5, #0]
    7c08:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    7c0a:	47a0      	blx	r4
}
    7c0c:	b005      	add	sp, #20
    7c0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    7c10:	0020      	movs	r0, r4
    7c12:	2300      	movs	r3, #0
    7c14:	a901      	add	r1, sp, #4
    7c16:	4c04      	ldr	r4, [pc, #16]	; (7c28 <xTimerGenericCommand+0x54>)
    7c18:	e7f7      	b.n	7c0a <xTimerGenericCommand+0x36>
    7c1a:	46c0      	nop			; (mov r8, r8)
    7c1c:	2000012c 	.word	0x2000012c
    7c20:	000073e9 	.word	0x000073e9
    7c24:	000076c5 	.word	0x000076c5
    7c28:	00007825 	.word	0x00007825

00007c2c <prvSwitchTimerLists>:
{
    7c2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    7c2e:	4d15      	ldr	r5, [pc, #84]	; (7c84 <prvSwitchTimerLists+0x58>)
    7c30:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    7c32:	681a      	ldr	r2, [r3, #0]
    7c34:	b91a      	cbnz	r2, 7c3e <prvSwitchTimerLists+0x12>
	pxCurrentTimerList = pxOverflowTimerList;
    7c36:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    7c38:	62ea      	str	r2, [r5, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
    7c3a:	632b      	str	r3, [r5, #48]	; 0x30
}
    7c3c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    7c3e:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7c40:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    7c42:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    7c44:	1d27      	adds	r7, r4, #4
    7c46:	4b10      	ldr	r3, [pc, #64]	; (7c88 <prvSwitchTimerLists+0x5c>)
    7c48:	0038      	movs	r0, r7
    7c4a:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    7c4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7c4e:	0020      	movs	r0, r4
    7c50:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    7c52:	69e3      	ldr	r3, [r4, #28]
    7c54:	2b01      	cmp	r3, #1
    7c56:	d1ea      	bne.n	7c2e <prvSwitchTimerLists+0x2>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    7c58:	69a3      	ldr	r3, [r4, #24]
    7c5a:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
    7c5c:	429e      	cmp	r6, r3
    7c5e:	d206      	bcs.n	7c6e <prvSwitchTimerLists+0x42>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    7c60:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    7c62:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    7c64:	0039      	movs	r1, r7
    7c66:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    7c68:	4b08      	ldr	r3, [pc, #32]	; (7c8c <prvSwitchTimerLists+0x60>)
    7c6a:	4798      	blx	r3
    7c6c:	e7df      	b.n	7c2e <prvSwitchTimerLists+0x2>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    7c6e:	2100      	movs	r1, #0
    7c70:	0020      	movs	r0, r4
    7c72:	9100      	str	r1, [sp, #0]
    7c74:	000b      	movs	r3, r1
    7c76:	0032      	movs	r2, r6
    7c78:	4c05      	ldr	r4, [pc, #20]	; (7c90 <prvSwitchTimerLists+0x64>)
    7c7a:	47a0      	blx	r4
				configASSERT( xResult );
    7c7c:	2800      	cmp	r0, #0
    7c7e:	d1d6      	bne.n	7c2e <prvSwitchTimerLists+0x2>
    7c80:	b672      	cpsid	i
    7c82:	e7fe      	b.n	7c82 <prvSwitchTimerLists+0x56>
    7c84:	2000012c 	.word	0x2000012c
    7c88:	00007adb 	.word	0x00007adb
    7c8c:	00007aad 	.word	0x00007aad
    7c90:	00007bd5 	.word	0x00007bd5

00007c94 <prvTimerTask>:
{
    7c94:	b5f0      	push	{r4, r5, r6, r7, lr}
    7c96:	b089      	sub	sp, #36	; 0x24
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    7c98:	4d55      	ldr	r5, [pc, #340]	; (7df0 <prvTimerTask+0x15c>)
    7c9a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    7c9c:	681c      	ldr	r4, [r3, #0]
    7c9e:	2c00      	cmp	r4, #0
    7ca0:	d000      	beq.n	7ca4 <prvTimerTask+0x10>
    7ca2:	e0a1      	b.n	7de8 <prvTimerTask+0x154>
    7ca4:	2301      	movs	r3, #1
    7ca6:	9302      	str	r3, [sp, #8]
	xTimeNow = xTaskGetTickCount();
    7ca8:	4f52      	ldr	r7, [pc, #328]	; (7df4 <prvTimerTask+0x160>)
	vTaskSuspendAll();
    7caa:	4b53      	ldr	r3, [pc, #332]	; (7df8 <prvTimerTask+0x164>)
    7cac:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    7cae:	47b8      	blx	r7
	if( xTimeNow < xLastTime )
    7cb0:	6bab      	ldr	r3, [r5, #56]	; 0x38
	xTimeNow = xTaskGetTickCount();
    7cb2:	0006      	movs	r6, r0
    7cb4:	9703      	str	r7, [sp, #12]
		*pxTimerListsWereSwitched = pdFALSE;
    7cb6:	2000      	movs	r0, #0
	if( xTimeNow < xLastTime )
    7cb8:	429e      	cmp	r6, r3
    7cba:	d202      	bcs.n	7cc2 <prvTimerTask+0x2e>
		prvSwitchTimerLists();
    7cbc:	4b4f      	ldr	r3, [pc, #316]	; (7dfc <prvTimerTask+0x168>)
    7cbe:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    7cc0:	2001      	movs	r0, #1
	xLastTime = xTimeNow;
    7cc2:	63ae      	str	r6, [r5, #56]	; 0x38
    7cc4:	4f4e      	ldr	r7, [pc, #312]	; (7e00 <prvTimerTask+0x16c>)
		if( xTimerListsWereSwitched == pdFALSE )
    7cc6:	2800      	cmp	r0, #0
    7cc8:	d163      	bne.n	7d92 <prvTimerTask+0xfe>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    7cca:	9b02      	ldr	r3, [sp, #8]
    7ccc:	2b00      	cmp	r3, #0
    7cce:	d151      	bne.n	7d74 <prvTimerTask+0xe0>
    7cd0:	42b4      	cmp	r4, r6
    7cd2:	d853      	bhi.n	7d7c <prvTimerTask+0xe8>
				( void ) xTaskResumeAll();
    7cd4:	47b8      	blx	r7
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7cd6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    7cd8:	68db      	ldr	r3, [r3, #12]
    7cda:	68dd      	ldr	r5, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    7cdc:	4b49      	ldr	r3, [pc, #292]	; (7e04 <prvTimerTask+0x170>)
    7cde:	1d28      	adds	r0, r5, #4
    7ce0:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    7ce2:	69eb      	ldr	r3, [r5, #28]
    7ce4:	2b01      	cmp	r3, #1
    7ce6:	d111      	bne.n	7d0c <prvTimerTask+0x78>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    7ce8:	69ab      	ldr	r3, [r5, #24]
    7cea:	0032      	movs	r2, r6
    7cec:	18e1      	adds	r1, r4, r3
    7cee:	0028      	movs	r0, r5
    7cf0:	0023      	movs	r3, r4
    7cf2:	4e45      	ldr	r6, [pc, #276]	; (7e08 <prvTimerTask+0x174>)
    7cf4:	47b0      	blx	r6
    7cf6:	b148      	cbz	r0, 7d0c <prvTimerTask+0x78>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    7cf8:	9b02      	ldr	r3, [sp, #8]
    7cfa:	0022      	movs	r2, r4
    7cfc:	9300      	str	r3, [sp, #0]
    7cfe:	0019      	movs	r1, r3
    7d00:	0028      	movs	r0, r5
    7d02:	4c42      	ldr	r4, [pc, #264]	; (7e0c <prvTimerTask+0x178>)
    7d04:	47a0      	blx	r4
			configASSERT( xResult );
    7d06:	b908      	cbnz	r0, 7d0c <prvTimerTask+0x78>
    7d08:	b672      	cpsid	i
    7d0a:	e7fe      	b.n	7d0a <prvTimerTask+0x76>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    7d0c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    7d0e:	0028      	movs	r0, r5
    7d10:	4798      	blx	r3
    7d12:	f240 2710 	movw	r7, #528	; 0x210
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    7d16:	4b36      	ldr	r3, [pc, #216]	; (7df0 <prvTimerTask+0x15c>)
    7d18:	2200      	movs	r2, #0
    7d1a:	6818      	ldr	r0, [r3, #0]
    7d1c:	a905      	add	r1, sp, #20
    7d1e:	4b3c      	ldr	r3, [pc, #240]	; (7e10 <prvTimerTask+0x17c>)
    7d20:	4798      	blx	r3
    7d22:	2800      	cmp	r0, #0
    7d24:	d0b8      	beq.n	7c98 <prvTimerTask+0x4>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    7d26:	9b05      	ldr	r3, [sp, #20]
    7d28:	2b00      	cmp	r3, #0
    7d2a:	dbf4      	blt.n	7d16 <prvTimerTask+0x82>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    7d2c:	9c07      	ldr	r4, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    7d2e:	6963      	ldr	r3, [r4, #20]
    7d30:	b113      	cbz	r3, 7d38 <prvTimerTask+0xa4>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    7d32:	1d20      	adds	r0, r4, #4
    7d34:	4b33      	ldr	r3, [pc, #204]	; (7e04 <prvTimerTask+0x170>)
    7d36:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    7d38:	9b03      	ldr	r3, [sp, #12]
    7d3a:	4798      	blx	r3
	if( xTimeNow < xLastTime )
    7d3c:	4b2c      	ldr	r3, [pc, #176]	; (7df0 <prvTimerTask+0x15c>)
	xTimeNow = xTaskGetTickCount();
    7d3e:	0005      	movs	r5, r0
	if( xTimeNow < xLastTime )
    7d40:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    7d42:	9302      	str	r3, [sp, #8]
    7d44:	4298      	cmp	r0, r3
    7d46:	d201      	bcs.n	7d4c <prvTimerTask+0xb8>
		prvSwitchTimerLists();
    7d48:	4b2c      	ldr	r3, [pc, #176]	; (7dfc <prvTimerTask+0x168>)
    7d4a:	4798      	blx	r3
	xLastTime = xTimeNow;
    7d4c:	4b28      	ldr	r3, [pc, #160]	; (7df0 <prvTimerTask+0x15c>)
    7d4e:	639d      	str	r5, [r3, #56]	; 0x38
    7d50:	9b05      	ldr	r3, [sp, #20]
    7d52:	2b09      	cmp	r3, #9
    7d54:	d8df      	bhi.n	7d16 <prvTimerTask+0x82>
    7d56:	2201      	movs	r2, #1
    7d58:	409a      	lsls	r2, r3
    7d5a:	0016      	movs	r6, r2
    7d5c:	403e      	ands	r6, r7
    7d5e:	0013      	movs	r3, r2
    7d60:	bbb6      	cbnz	r6, 7dd0 <prvTimerTask+0x13c>
    7d62:	22c7      	movs	r2, #199	; 0xc7
    7d64:	4213      	tst	r3, r2
    7d66:	d116      	bne.n	7d96 <prvTimerTask+0x102>
    7d68:	069b      	lsls	r3, r3, #26
    7d6a:	d5d4      	bpl.n	7d16 <prvTimerTask+0x82>
						vPortFree( pxTimer );
    7d6c:	0020      	movs	r0, r4
    7d6e:	4b29      	ldr	r3, [pc, #164]	; (7e14 <prvTimerTask+0x180>)
    7d70:	4798      	blx	r3
    7d72:	e7d0      	b.n	7d16 <prvTimerTask+0x82>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    7d74:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    7d76:	681a      	ldr	r2, [r3, #0]
    7d78:	4250      	negs	r0, r2
    7d7a:	4150      	adcs	r0, r2
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    7d7c:	0002      	movs	r2, r0
    7d7e:	1ba1      	subs	r1, r4, r6
    7d80:	6828      	ldr	r0, [r5, #0]
    7d82:	4b25      	ldr	r3, [pc, #148]	; (7e18 <prvTimerTask+0x184>)
    7d84:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    7d86:	47b8      	blx	r7
    7d88:	2800      	cmp	r0, #0
    7d8a:	d1c2      	bne.n	7d12 <prvTimerTask+0x7e>
					portYIELD_WITHIN_API();
    7d8c:	4b23      	ldr	r3, [pc, #140]	; (7e1c <prvTimerTask+0x188>)
    7d8e:	4798      	blx	r3
    7d90:	e7bf      	b.n	7d12 <prvTimerTask+0x7e>
			( void ) xTaskResumeAll();
    7d92:	47b8      	blx	r7
    7d94:	e7bd      	b.n	7d12 <prvTimerTask+0x7e>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    7d96:	9b06      	ldr	r3, [sp, #24]
    7d98:	69a2      	ldr	r2, [r4, #24]
    7d9a:	0020      	movs	r0, r4
    7d9c:	1899      	adds	r1, r3, r2
    7d9e:	002a      	movs	r2, r5
    7da0:	4d19      	ldr	r5, [pc, #100]	; (7e08 <prvTimerTask+0x174>)
    7da2:	9302      	str	r3, [sp, #8]
    7da4:	47a8      	blx	r5
    7da6:	2800      	cmp	r0, #0
    7da8:	d0b5      	beq.n	7d16 <prvTimerTask+0x82>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    7daa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7dac:	0020      	movs	r0, r4
    7dae:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    7db0:	69e3      	ldr	r3, [r4, #28]
    7db2:	2b01      	cmp	r3, #1
    7db4:	d1af      	bne.n	7d16 <prvTimerTask+0x82>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    7db6:	69a3      	ldr	r3, [r4, #24]
    7db8:	9a06      	ldr	r2, [sp, #24]
    7dba:	0020      	movs	r0, r4
    7dbc:	18d2      	adds	r2, r2, r3
    7dbe:	9600      	str	r6, [sp, #0]
    7dc0:	0033      	movs	r3, r6
    7dc2:	0031      	movs	r1, r6
    7dc4:	4c11      	ldr	r4, [pc, #68]	; (7e0c <prvTimerTask+0x178>)
    7dc6:	47a0      	blx	r4
							configASSERT( xResult );
    7dc8:	2800      	cmp	r0, #0
    7dca:	d1a4      	bne.n	7d16 <prvTimerTask+0x82>
    7dcc:	b672      	cpsid	i
    7dce:	e7fe      	b.n	7dce <prvTimerTask+0x13a>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    7dd0:	9906      	ldr	r1, [sp, #24]
    7dd2:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    7dd4:	b909      	cbnz	r1, 7dda <prvTimerTask+0x146>
    7dd6:	b672      	cpsid	i
    7dd8:	e7fe      	b.n	7dd8 <prvTimerTask+0x144>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    7dda:	1949      	adds	r1, r1, r5
    7ddc:	002b      	movs	r3, r5
    7dde:	002a      	movs	r2, r5
    7de0:	0020      	movs	r0, r4
    7de2:	4c09      	ldr	r4, [pc, #36]	; (7e08 <prvTimerTask+0x174>)
    7de4:	47a0      	blx	r4
    7de6:	e796      	b.n	7d16 <prvTimerTask+0x82>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    7de8:	68db      	ldr	r3, [r3, #12]
    7dea:	681c      	ldr	r4, [r3, #0]
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    7dec:	2300      	movs	r3, #0
    7dee:	e75a      	b.n	7ca6 <prvTimerTask+0x12>
    7df0:	2000012c 	.word	0x2000012c
    7df4:	00006fc9 	.word	0x00006fc9
    7df8:	00006fb9 	.word	0x00006fb9
    7dfc:	00007c2d 	.word	0x00007c2d
    7e00:	000070bd 	.word	0x000070bd
    7e04:	00007adb 	.word	0x00007adb
    7e08:	00007b55 	.word	0x00007b55
    7e0c:	00007bd5 	.word	0x00007bd5
    7e10:	000078d5 	.word	0x000078d5
    7e14:	00007e81 	.word	0x00007e81
    7e18:	00007a21 	.word	0x00007a21
    7e1c:	00007f75 	.word	0x00007f75

00007e20 <pvPortMalloc>:
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    7e20:	2307      	movs	r3, #7
{
    7e22:	b570      	push	{r4, r5, r6, lr}
    7e24:	0004      	movs	r4, r0
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    7e26:	4218      	tst	r0, r3
    7e28:	d001      	beq.n	7e2e <pvPortMalloc+0xe>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    7e2a:	439c      	bics	r4, r3
    7e2c:	3408      	adds	r4, #8
		}
	}
	#endif

	vTaskSuspendAll();
    7e2e:	4b0f      	ldr	r3, [pc, #60]	; (7e6c <pvPortMalloc+0x4c>)
    7e30:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
    7e32:	4b0f      	ldr	r3, [pc, #60]	; (7e70 <pvPortMalloc+0x50>)
    7e34:	681a      	ldr	r2, [r3, #0]
    7e36:	b922      	cbnz	r2, 7e42 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    7e38:	001a      	movs	r2, r3
    7e3a:	2107      	movs	r1, #7
    7e3c:	320c      	adds	r2, #12
    7e3e:	438a      	bics	r2, r1
    7e40:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    7e42:	f642 20ef 	movw	r0, #10991	; 0x2aef
    7e46:	490b      	ldr	r1, [pc, #44]	; (7e74 <pvPortMalloc+0x54>)
void *pvReturn = NULL;
    7e48:	2500      	movs	r5, #0
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    7e4a:	6fca      	ldr	r2, [r1, #124]	; 0x7c
    7e4c:	18a4      	adds	r4, r4, r2
    7e4e:	4284      	cmp	r4, r0
    7e50:	d804      	bhi.n	7e5c <pvPortMalloc+0x3c>
    7e52:	42a2      	cmp	r2, r4
    7e54:	d202      	bcs.n	7e5c <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    7e56:	681d      	ldr	r5, [r3, #0]
			xNextFreeByte += xWantedSize;
    7e58:	67cc      	str	r4, [r1, #124]	; 0x7c
			pvReturn = pucAlignedHeap + xNextFreeByte;
    7e5a:	18ad      	adds	r5, r5, r2
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    7e5c:	4b06      	ldr	r3, [pc, #24]	; (7e78 <pvPortMalloc+0x58>)
    7e5e:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    7e60:	b90d      	cbnz	r5, 7e66 <pvPortMalloc+0x46>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    7e62:	4b06      	ldr	r3, [pc, #24]	; (7e7c <pvPortMalloc+0x5c>)
    7e64:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
}
    7e66:	0028      	movs	r0, r5
    7e68:	bd70      	pop	{r4, r5, r6, pc}
    7e6a:	46c0      	nop			; (mov r8, r8)
    7e6c:	00006fb9 	.word	0x00006fb9
    7e70:	20000168 	.word	0x20000168
    7e74:	20002be8 	.word	0x20002be8
    7e78:	000070bd 	.word	0x000070bd
    7e7c:	000080ad 	.word	0x000080ad

00007e80 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
    7e80:	b108      	cbz	r0, 7e86 <vPortFree+0x6>
    7e82:	b672      	cpsid	i
    7e84:	e7fe      	b.n	7e84 <vPortFree+0x4>
}
    7e86:	4770      	bx	lr

00007e88 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
volatile uint32_t ulDummy = 0UL;
    7e88:	2300      	movs	r3, #0
{
    7e8a:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
    7e8c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    7e8e:	4b06      	ldr	r3, [pc, #24]	; (7ea8 <prvTaskExitError+0x20>)
    7e90:	681b      	ldr	r3, [r3, #0]
    7e92:	3301      	adds	r3, #1
    7e94:	d001      	beq.n	7e9a <prvTaskExitError+0x12>
    7e96:	b672      	cpsid	i
    7e98:	e7fe      	b.n	7e98 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
    7e9a:	b672      	cpsid	i
	while( ulDummy == 0 )
    7e9c:	9b01      	ldr	r3, [sp, #4]
    7e9e:	2b00      	cmp	r3, #0
    7ea0:	d0fc      	beq.n	7e9c <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
    7ea2:	b002      	add	sp, #8
    7ea4:	4770      	bx	lr
    7ea6:	46c0      	nop			; (mov r8, r8)
    7ea8:	20000004 	.word	0x20000004
    7eac:	00000000 	.word	0x00000000

00007eb0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    7eb0:	4a0b      	ldr	r2, [pc, #44]	; (7ee0 <pxCurrentTCBConst2>)
    7eb2:	6813      	ldr	r3, [r2, #0]
    7eb4:	6818      	ldr	r0, [r3, #0]
    7eb6:	3020      	adds	r0, #32
    7eb8:	f380 8809 	msr	PSP, r0
    7ebc:	2002      	movs	r0, #2
    7ebe:	f380 8814 	msr	CONTROL, r0
    7ec2:	f3bf 8f6f 	isb	sy
    7ec6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    7ec8:	46ae      	mov	lr, r5
    7eca:	bc08      	pop	{r3}
    7ecc:	bc04      	pop	{r2}
    7ece:	b662      	cpsie	i
    7ed0:	4718      	bx	r3
    7ed2:	46c0      	nop			; (mov r8, r8)
    7ed4:	46c0      	nop			; (mov r8, r8)
    7ed6:	46c0      	nop			; (mov r8, r8)
    7ed8:	46c0      	nop			; (mov r8, r8)
    7eda:	46c0      	nop			; (mov r8, r8)
    7edc:	46c0      	nop			; (mov r8, r8)
    7ede:	46c0      	nop			; (mov r8, r8)

00007ee0 <pxCurrentTCBConst2>:
    7ee0:	20000034 	.word	0x20000034

00007ee4 <pxPortInitialiseStack>:
{
    7ee4:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    7ee6:	2480      	movs	r4, #128	; 0x80
    7ee8:	1f03      	subs	r3, r0, #4
    7eea:	0464      	lsls	r4, r4, #17
    7eec:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
    7eee:	3b04      	subs	r3, #4
    7ef0:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    7ef2:	4903      	ldr	r1, [pc, #12]	; (7f00 <pxPortInitialiseStack+0x1c>)
    7ef4:	3b04      	subs	r3, #4
    7ef6:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    7ef8:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
    7efa:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    7efc:	601a      	str	r2, [r3, #0]
}
    7efe:	bd10      	pop	{r4, pc}
    7f00:	00007e89 	.word	0x00007e89

00007f04 <xPortStartScheduler>:
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    7f04:	22ff      	movs	r2, #255	; 0xff
    7f06:	4b12      	ldr	r3, [pc, #72]	; (7f50 <xPortStartScheduler+0x4c>)
    7f08:	0412      	lsls	r2, r2, #16
    7f0a:	6819      	ldr	r1, [r3, #0]
{
    7f0c:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    7f0e:	430a      	orrs	r2, r1
    7f10:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    7f12:	22ff      	movs	r2, #255	; 0xff
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
    7f14:	2400      	movs	r4, #0
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    7f16:	6819      	ldr	r1, [r3, #0]
    7f18:	0612      	lsls	r2, r2, #24
    7f1a:	430a      	orrs	r2, r1
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    7f1c:	f240 11f4 	movw	r1, #500	; 0x1f4
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    7f20:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = 0UL;
    7f22:	4a0c      	ldr	r2, [pc, #48]	; (7f54 <xPortStartScheduler+0x50>)
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
    7f24:	4b0c      	ldr	r3, [pc, #48]	; (7f58 <xPortStartScheduler+0x54>)
	*(portNVIC_SYSTICK_CTRL) = 0UL;
    7f26:	6014      	str	r4, [r2, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
    7f28:	601c      	str	r4, [r3, #0]
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    7f2a:	4b0c      	ldr	r3, [pc, #48]	; (7f5c <xPortStartScheduler+0x58>)
    7f2c:	681b      	ldr	r3, [r3, #0]
    7f2e:	fbb3 f3f1 	udiv	r3, r3, r1
    7f32:	490b      	ldr	r1, [pc, #44]	; (7f60 <xPortStartScheduler+0x5c>)
    7f34:	3b01      	subs	r3, #1
    7f36:	600b      	str	r3, [r1, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    7f38:	2307      	movs	r3, #7
    7f3a:	6013      	str	r3, [r2, #0]
	uxCriticalNesting = 0;
    7f3c:	4b09      	ldr	r3, [pc, #36]	; (7f64 <xPortStartScheduler+0x60>)
    7f3e:	601c      	str	r4, [r3, #0]
	vPortStartFirstTask();
    7f40:	4b09      	ldr	r3, [pc, #36]	; (7f68 <xPortStartScheduler+0x64>)
    7f42:	4798      	blx	r3
	vTaskSwitchContext();
    7f44:	4b09      	ldr	r3, [pc, #36]	; (7f6c <xPortStartScheduler+0x68>)
    7f46:	4798      	blx	r3
	prvTaskExitError();
    7f48:	4b09      	ldr	r3, [pc, #36]	; (7f70 <xPortStartScheduler+0x6c>)
    7f4a:	4798      	blx	r3
}
    7f4c:	0020      	movs	r0, r4
    7f4e:	bd10      	pop	{r4, pc}
    7f50:	e000ed20 	.word	0xe000ed20
    7f54:	e000e010 	.word	0xe000e010
    7f58:	e000e018 	.word	0xe000e018
    7f5c:	20000000 	.word	0x20000000
    7f60:	e000e014 	.word	0xe000e014
    7f64:	20000004 	.word	0x20000004
    7f68:	00007eb1 	.word	0x00007eb1
    7f6c:	000071f5 	.word	0x000071f5
    7f70:	00007e89 	.word	0x00007e89

00007f74 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    7f74:	2280      	movs	r2, #128	; 0x80
    7f76:	4b04      	ldr	r3, [pc, #16]	; (7f88 <vPortYield+0x14>)
    7f78:	0552      	lsls	r2, r2, #21
    7f7a:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
    7f7c:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    7f80:	f3bf 8f6f 	isb	sy
}
    7f84:	4770      	bx	lr
    7f86:	46c0      	nop			; (mov r8, r8)
    7f88:	e000ed04 	.word	0xe000ed04

00007f8c <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
    7f8c:	b672      	cpsid	i
    uxCriticalNesting++;
    7f8e:	4a04      	ldr	r2, [pc, #16]	; (7fa0 <vPortEnterCritical+0x14>)
    7f90:	6813      	ldr	r3, [r2, #0]
    7f92:	3301      	adds	r3, #1
    7f94:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
    7f96:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    7f9a:	f3bf 8f6f 	isb	sy
}
    7f9e:	4770      	bx	lr
    7fa0:	20000004 	.word	0x20000004

00007fa4 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
    7fa4:	4a04      	ldr	r2, [pc, #16]	; (7fb8 <vPortExitCritical+0x14>)
    7fa6:	6813      	ldr	r3, [r2, #0]
    7fa8:	b90b      	cbnz	r3, 7fae <vPortExitCritical+0xa>
    7faa:	b672      	cpsid	i
    7fac:	e7fe      	b.n	7fac <vPortExitCritical+0x8>
    uxCriticalNesting--;
    7fae:	3b01      	subs	r3, #1
    7fb0:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
    7fb2:	b903      	cbnz	r3, 7fb6 <vPortExitCritical+0x12>
        portENABLE_INTERRUPTS();
    7fb4:	b662      	cpsie	i
}
    7fb6:	4770      	bx	lr
    7fb8:	20000004 	.word	0x20000004

00007fbc <ulSetInterruptMaskFromISR>:
	__asm volatile(
    7fbc:	f3ef 8010 	mrs	r0, PRIMASK
    7fc0:	b672      	cpsid	i
    7fc2:	4770      	bx	lr

00007fc4 <vClearInterruptMaskFromISR>:
	__asm volatile(
    7fc4:	f380 8810 	msr	PRIMASK, r0
    7fc8:	4770      	bx	lr
    7fca:	0000      	movs	r0, r0
    7fcc:	0000      	movs	r0, r0
	...

00007fd0 <PendSV_Handler>:
	__asm volatile
    7fd0:	f3ef 8009 	mrs	r0, PSP
    7fd4:	4b0e      	ldr	r3, [pc, #56]	; (8010 <pxCurrentTCBConst>)
    7fd6:	681a      	ldr	r2, [r3, #0]
    7fd8:	3820      	subs	r0, #32
    7fda:	6010      	str	r0, [r2, #0]
    7fdc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    7fde:	4644      	mov	r4, r8
    7fe0:	464d      	mov	r5, r9
    7fe2:	4656      	mov	r6, sl
    7fe4:	465f      	mov	r7, fp
    7fe6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    7fe8:	b508      	push	{r3, lr}
    7fea:	b672      	cpsid	i
    7fec:	f7ff f902 	bl	71f4 <vTaskSwitchContext>
    7ff0:	b662      	cpsie	i
    7ff2:	bc0c      	pop	{r2, r3}
    7ff4:	6811      	ldr	r1, [r2, #0]
    7ff6:	6808      	ldr	r0, [r1, #0]
    7ff8:	3010      	adds	r0, #16
    7ffa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    7ffc:	46a0      	mov	r8, r4
    7ffe:	46a9      	mov	r9, r5
    8000:	46b2      	mov	sl, r6
    8002:	46bb      	mov	fp, r7
    8004:	f380 8809 	msr	PSP, r0
    8008:	3820      	subs	r0, #32
    800a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    800c:	4718      	bx	r3
    800e:	46c0      	nop			; (mov r8, r8)

00008010 <pxCurrentTCBConst>:
    8010:	20000034 	.word	0x20000034

00008014 <SysTick_Handler>:
{
    8014:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    8016:	4b07      	ldr	r3, [pc, #28]	; (8034 <SysTick_Handler+0x20>)
    8018:	4798      	blx	r3
		if( xTaskIncrementTick() != pdFALSE )
    801a:	4b07      	ldr	r3, [pc, #28]	; (8038 <SysTick_Handler+0x24>)
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    801c:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
    801e:	4798      	blx	r3
    8020:	b118      	cbz	r0, 802a <SysTick_Handler+0x16>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    8022:	2280      	movs	r2, #128	; 0x80
    8024:	4b05      	ldr	r3, [pc, #20]	; (803c <SysTick_Handler+0x28>)
    8026:	0552      	lsls	r2, r2, #21
    8028:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
    802a:	0020      	movs	r0, r4
    802c:	4b04      	ldr	r3, [pc, #16]	; (8040 <SysTick_Handler+0x2c>)
    802e:	4798      	blx	r3
}
    8030:	bd10      	pop	{r4, pc}
    8032:	46c0      	nop			; (mov r8, r8)
    8034:	00007fbd 	.word	0x00007fbd
    8038:	00006fd5 	.word	0x00006fd5
    803c:	e000ed04 	.word	0xe000ed04
    8040:	00007fc5 	.word	0x00007fc5

00008044 <vParTestInitialise>:
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8044:	2280      	movs	r2, #128	; 0x80
    8046:	4b09      	ldr	r3, [pc, #36]	; (806c <vParTestInitialise+0x28>)

/*-----------------------------------------------------------*/

/* UPDATE */
void vParTestInitialise( void )
{
    8048:	b510      	push	{r4, lr}
    804a:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    804c:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    804e:	4b08      	ldr	r3, [pc, #32]	; (8070 <vParTestInitialise+0x2c>)
    8050:	4a08      	ldr	r2, [pc, #32]	; (8074 <vParTestInitialise+0x30>)
	tmp &= ~PORT_PINCFG_PMUXEN_Msk;
    8052:	2101      	movs	r1, #1
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    8054:	629a      	str	r2, [r3, #40]	; 0x28
    8056:	22c0      	movs	r2, #192	; 0xc0
    8058:	0612      	lsls	r2, r2, #24
    805a:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    805c:	3347      	adds	r3, #71	; 0x47
    805e:	781a      	ldrb	r2, [r3, #0]
	/* Configure relevant port P0 to push pull output to drive LEDs. */
	gpio_set_pin_level(LED0, false);
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
	gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

	delay_init(SysTick);
    8060:	4805      	ldr	r0, [pc, #20]	; (8078 <vParTestInitialise+0x34>)
	tmp &= ~PORT_PINCFG_PMUXEN_Msk;
    8062:	438a      	bics	r2, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    8064:	701a      	strb	r2, [r3, #0]
    8066:	4b05      	ldr	r3, [pc, #20]	; (807c <vParTestInitialise+0x38>)
    8068:	4798      	blx	r3
}
    806a:	bd10      	pop	{r4, pc}
    806c:	60000200 	.word	0x60000200
    8070:	40003200 	.word	0x40003200
    8074:	40000080 	.word	0x40000080
    8078:	e000e010 	.word	0xe000e010
    807c:	00006cdd 	.word	0x00006cdd

00008080 <vParTestToggleLED>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    8080:	2280      	movs	r2, #128	; 0x80
    8082:	4b01      	ldr	r3, [pc, #4]	; (8088 <vParTestToggleLED+0x8>)
    8084:	61da      	str	r2, [r3, #28]
/* UPDATE */
void vParTestToggleLED( unsigned long ulLED )
{

	gpio_toggle_pin_level(LED0);
}
    8086:	4770      	bx	lr
    8088:	60000200 	.word	0x60000200

0000808c <main>:
extern void SystemCoreClockUpdate( void );

/*-----------------------------------------------------------*/

int main( void )
{
    808c:	b510      	push	{r4, lr}
}
/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
	SystemCoreClockUpdate();
    808e:	4b04      	ldr	r3, [pc, #16]	; (80a0 <main+0x14>)
    8090:	4798      	blx	r3
	vParTestInitialise();
    8092:	4b04      	ldr	r3, [pc, #16]	; (80a4 <main+0x18>)
    8094:	4798      	blx	r3
		main_blinky();
    8096:	4b04      	ldr	r3, [pc, #16]	; (80a8 <main+0x1c>)
    8098:	4798      	blx	r3
}
    809a:	2000      	movs	r0, #0
    809c:	bd10      	pop	{r4, pc}
    809e:	46c0      	nop			; (mov r8, r8)
    80a0:	00006c61 	.word	0x00006c61
    80a4:	00008045 	.word	0x00008045
    80a8:	00008131 	.word	0x00008131

000080ac <vApplicationMallocFailedHook>:
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
    80ac:	b672      	cpsid	i
    80ae:	e7fe      	b.n	80ae <vApplicationMallocFailedHook+0x2>

000080b0 <vApplicationStackOverflowHook>:
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
    80b0:	b672      	cpsid	i
    80b2:	e7fe      	b.n	80b2 <vApplicationStackOverflowHook+0x2>

000080b4 <vApplicationTickHook>:
		/* Write to a queue that is in use as part of the queue set demo to
		demonstrate using queue sets from an ISR. */
		vQueueSetAccessQueueSetFromISR();
	}
	#endif /* mainCREATE_SIMPLE_BLINKY_DEMO_ONLY */
}
    80b4:	4770      	bx	lr
	...

000080b8 <prvQueueSendTask>:
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
TickType_t xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
    80b8:	2364      	movs	r3, #100	; 0x64
{
    80ba:	b513      	push	{r0, r1, r4, lr}
const unsigned long ulValueToSend = 100UL;
    80bc:	9301      	str	r3, [sp, #4]

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_SEND_PARAMETER );
    80be:	f241 1311 	movw	r3, #4369	; 0x1111
    80c2:	4298      	cmp	r0, r3
    80c4:	d001      	beq.n	80ca <prvQueueSendTask+0x12>
    80c6:	b672      	cpsid	i
    80c8:	e7fe      	b.n	80c8 <prvQueueSendTask+0x10>

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
    80ca:	4b07      	ldr	r3, [pc, #28]	; (80e8 <prvQueueSendTask+0x30>)
    80cc:	4798      	blx	r3
    80ce:	9000      	str	r0, [sp, #0]
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
    80d0:	4668      	mov	r0, sp
    80d2:	21c8      	movs	r1, #200	; 0xc8
    80d4:	4b05      	ldr	r3, [pc, #20]	; (80ec <prvQueueSendTask+0x34>)
    80d6:	4798      	blx	r3

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, 0U );
    80d8:	2300      	movs	r3, #0
    80da:	4805      	ldr	r0, [pc, #20]	; (80f0 <prvQueueSendTask+0x38>)
    80dc:	001a      	movs	r2, r3
    80de:	a901      	add	r1, sp, #4
    80e0:	4c04      	ldr	r4, [pc, #16]	; (80f4 <prvQueueSendTask+0x3c>)
    80e2:	6800      	ldr	r0, [r0, #0]
    80e4:	47a0      	blx	r4
    80e6:	e7f3      	b.n	80d0 <prvQueueSendTask+0x18>
    80e8:	00006fc9 	.word	0x00006fc9
    80ec:	00007185 	.word	0x00007185
    80f0:	20002c68 	.word	0x20002c68
    80f4:	000076c5 	.word	0x000076c5

000080f8 <prvQueueReceiveTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
    80f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
unsigned long ulReceivedValue;

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_RECEIVE_PARAMETER );
    80fa:	2822      	cmp	r0, #34	; 0x22
    80fc:	d110      	bne.n	8120 <prvQueueReceiveTask+0x28>
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
    80fe:	2501      	movs	r5, #1

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
		{
			vParTestToggleLED( mainLED_TO_TOGGLE );
    8100:	2400      	movs	r4, #0
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
    8102:	426d      	negs	r5, r5
    8104:	4b07      	ldr	r3, [pc, #28]	; (8124 <prvQueueReceiveTask+0x2c>)
    8106:	002a      	movs	r2, r5
    8108:	6818      	ldr	r0, [r3, #0]
    810a:	a901      	add	r1, sp, #4
    810c:	4b06      	ldr	r3, [pc, #24]	; (8128 <prvQueueReceiveTask+0x30>)
    810e:	4798      	blx	r3
		if( ulReceivedValue == 100UL )
    8110:	9b01      	ldr	r3, [sp, #4]
    8112:	2b64      	cmp	r3, #100	; 0x64
    8114:	d1f6      	bne.n	8104 <prvQueueReceiveTask+0xc>
			vParTestToggleLED( mainLED_TO_TOGGLE );
    8116:	2000      	movs	r0, #0
    8118:	4b04      	ldr	r3, [pc, #16]	; (812c <prvQueueReceiveTask+0x34>)
    811a:	4798      	blx	r3
			ulReceivedValue = 0U;
    811c:	9401      	str	r4, [sp, #4]
    811e:	e7f1      	b.n	8104 <prvQueueReceiveTask+0xc>
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_RECEIVE_PARAMETER );
    8120:	b672      	cpsid	i
    8122:	e7fe      	b.n	8122 <prvQueueReceiveTask+0x2a>
    8124:	20002c68 	.word	0x20002c68
    8128:	000078d5 	.word	0x000078d5
    812c:	00008081 	.word	0x00008081

00008130 <main_blinky>:
{
    8130:	b537      	push	{r0, r1, r2, r4, r5, lr}
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
    8132:	4b0f      	ldr	r3, [pc, #60]	; (8170 <main_blinky+0x40>)
    8134:	2200      	movs	r2, #0
    8136:	2104      	movs	r1, #4
    8138:	2001      	movs	r0, #1
    813a:	4798      	blx	r3
    813c:	4b0d      	ldr	r3, [pc, #52]	; (8174 <main_blinky+0x44>)
    813e:	6018      	str	r0, [r3, #0]
	if( xQueue != NULL )
    8140:	b1a0      	cbz	r0, 816c <main_blinky+0x3c>
		xTaskCreate( prvQueueReceiveTask,					/* The function that implements the task. */
    8142:	2500      	movs	r5, #0
    8144:	2302      	movs	r3, #2
    8146:	223c      	movs	r2, #60	; 0x3c
    8148:	9300      	str	r3, [sp, #0]
    814a:	490b      	ldr	r1, [pc, #44]	; (8178 <main_blinky+0x48>)
    814c:	3320      	adds	r3, #32
    814e:	4c0b      	ldr	r4, [pc, #44]	; (817c <main_blinky+0x4c>)
    8150:	9501      	str	r5, [sp, #4]
    8152:	480b      	ldr	r0, [pc, #44]	; (8180 <main_blinky+0x50>)
    8154:	47a0      	blx	r4
		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, ( void * ) mainQUEUE_SEND_PARAMETER, mainQUEUE_SEND_TASK_PRIORITY, NULL );
    8156:	2301      	movs	r3, #1
    8158:	9501      	str	r5, [sp, #4]
    815a:	9300      	str	r3, [sp, #0]
    815c:	223c      	movs	r2, #60	; 0x3c
    815e:	f241 1311 	movw	r3, #4369	; 0x1111
    8162:	4908      	ldr	r1, [pc, #32]	; (8184 <main_blinky+0x54>)
    8164:	4808      	ldr	r0, [pc, #32]	; (8188 <main_blinky+0x58>)
    8166:	47a0      	blx	r4
		vTaskStartScheduler();
    8168:	4b08      	ldr	r3, [pc, #32]	; (818c <main_blinky+0x5c>)
    816a:	4798      	blx	r3
    816c:	e7fe      	b.n	816c <main_blinky+0x3c>
    816e:	46c0      	nop			; (mov r8, r8)
    8170:	00007679 	.word	0x00007679
    8174:	20002c68 	.word	0x20002c68
    8178:	00008214 	.word	0x00008214
    817c:	00006dc9 	.word	0x00006dc9
    8180:	000080f9 	.word	0x000080f9
    8184:	00008217 	.word	0x00008217
    8188:	000080b9 	.word	0x000080b9
    818c:	00006f59 	.word	0x00006f59

00008190 <__libc_init_array>:
    8190:	b570      	push	{r4, r5, r6, lr}
    8192:	2500      	movs	r5, #0
    8194:	4b0e      	ldr	r3, [pc, #56]	; (81d0 <__libc_init_array+0x40>)
    8196:	4c0f      	ldr	r4, [pc, #60]	; (81d4 <__libc_init_array+0x44>)
    8198:	1ae4      	subs	r4, r4, r3
    819a:	10a4      	asrs	r4, r4, #2
    819c:	42a5      	cmp	r5, r4
    819e:	d109      	bne.n	81b4 <__libc_init_array+0x24>
    81a0:	2500      	movs	r5, #0
    81a2:	f000 f83b 	bl	821c <_init>
    81a6:	4c0c      	ldr	r4, [pc, #48]	; (81d8 <__libc_init_array+0x48>)
    81a8:	4b0c      	ldr	r3, [pc, #48]	; (81dc <__libc_init_array+0x4c>)
    81aa:	1ae4      	subs	r4, r4, r3
    81ac:	10a4      	asrs	r4, r4, #2
    81ae:	42a5      	cmp	r5, r4
    81b0:	d107      	bne.n	81c2 <__libc_init_array+0x32>
    81b2:	bd70      	pop	{r4, r5, r6, pc}
    81b4:	4a06      	ldr	r2, [pc, #24]	; (81d0 <__libc_init_array+0x40>)
    81b6:	00ab      	lsls	r3, r5, #2
    81b8:	189b      	adds	r3, r3, r2
    81ba:	681b      	ldr	r3, [r3, #0]
    81bc:	4798      	blx	r3
    81be:	3501      	adds	r5, #1
    81c0:	e7ec      	b.n	819c <__libc_init_array+0xc>
    81c2:	4a06      	ldr	r2, [pc, #24]	; (81dc <__libc_init_array+0x4c>)
    81c4:	00ab      	lsls	r3, r5, #2
    81c6:	189b      	adds	r3, r3, r2
    81c8:	681b      	ldr	r3, [r3, #0]
    81ca:	4798      	blx	r3
    81cc:	3501      	adds	r5, #1
    81ce:	e7ee      	b.n	81ae <__libc_init_array+0x1e>
    81d0:	00008228 	.word	0x00008228
    81d4:	00008228 	.word	0x00008228
    81d8:	0000822c 	.word	0x0000822c
    81dc:	00008228 	.word	0x00008228

000081e0 <memcpy>:
    81e0:	2300      	movs	r3, #0
    81e2:	b510      	push	{r4, lr}
    81e4:	429a      	cmp	r2, r3
    81e6:	d100      	bne.n	81ea <memcpy+0xa>
    81e8:	bd10      	pop	{r4, pc}
    81ea:	5ccc      	ldrb	r4, [r1, r3]
    81ec:	54c4      	strb	r4, [r0, r3]
    81ee:	3301      	adds	r3, #1
    81f0:	e7f8      	b.n	81e4 <memcpy+0x4>

000081f2 <memset>:
    81f2:	0003      	movs	r3, r0
    81f4:	1882      	adds	r2, r0, r2
    81f6:	4293      	cmp	r3, r2
    81f8:	d100      	bne.n	81fc <memset+0xa>
    81fa:	4770      	bx	lr
    81fc:	7019      	strb	r1, [r3, #0]
    81fe:	3301      	adds	r3, #1
    8200:	e7f9      	b.n	81f6 <memset+0x4>
    8202:	4449      	.short	0x4449
    8204:	454c      	.short	0x454c
    8206:	00          	.byte	0x00
    8207:	54          	.byte	0x54
    8208:	0051726d 	.word	0x0051726d
    820c:	20726d54 	.word	0x20726d54
    8210:	00637653 	.word	0x00637653
    8214:	54007852 	.word	0x54007852
    8218:	00000058 	.word	0x00000058

0000821c <_init>:
    821c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    821e:	46c0      	nop			; (mov r8, r8)
    8220:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8222:	bc08      	pop	{r3}
    8224:	469e      	mov	lr, r3
    8226:	4770      	bx	lr

00008228 <__init_array_start>:
    8228:	00006c21 	.word	0x00006c21

0000822c <_fini>:
    822c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    822e:	46c0      	nop			; (mov r8, r8)
    8230:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8232:	bc08      	pop	{r3}
    8234:	469e      	mov	lr, r3
    8236:	4770      	bx	lr

00008238 <__fini_array_start>:
    8238:	00006bf5 	.word	0x00006bf5
